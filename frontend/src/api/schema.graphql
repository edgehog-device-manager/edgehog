schema {
  mutation: RootMutationType
  query: RootQueryType
}

enum SystemModelPartNumberSortField {
  ID
  PART_NUMBER
}

input SystemModelPartNumberFilterPartNumber {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelPartNumberFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input SystemModelPartNumberFilterInput {
  and: [SystemModelPartNumberFilterInput!]

  or: [SystemModelPartNumberFilterInput!]

  not: [SystemModelPartNumberFilterInput!]

  id: SystemModelPartNumberFilterId

  "The part number identifier."
  partNumber: SystemModelPartNumberFilterPartNumber

  systemModel: SystemModelFilterInput

  devices: DeviceFilterInput
}

input SystemModelPartNumberSortInput {
  order: SortOrder
  field: SystemModelPartNumberSortField!
}

type SystemModelPartNumber {
  id: ID!

  "The part number identifier."
  partNumber: String!

  systemModel: SystemModel

  devices(
    "How to sort the records in the response"
    sort: [DeviceSortInput]

    "A filter to limit the results"
    filter: DeviceFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [Device!]!
}

"The result of the :delete_system_model mutation"
type DeleteSystemModelResult {
  "The record that was successfully deleted"
  result: SystemModel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

"The result of the :update_system_model mutation"
type UpdateSystemModelResult {
  "The successful result of the mutation"
  result: SystemModel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

input UpdateSystemModelInput {
  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  "The display name of the system model."
  name: String

  "A URL to a picture representing the system model."
  pictureUrl: String

  "The list of part numbers associated with the system model."
  partNumbers: [String!]

  "A picture representing the system model that will be uploaded to a bucket."
  pictureFile: Upload
}

"The result of the :create_system_model mutation"
type CreateSystemModelResult {
  "The successful result of the mutation"
  result: SystemModel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

input CreateSystemModelInput {
  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the system model."
  name: String!

  "A URL to a picture representing the system model."
  pictureUrl: String

  "The ID of the hardware type that can be used by devices of this model"
  hardwareTypeId: ID!

  "The list of part numbers associated with the system model."
  partNumbers: [String!]!

  "A picture representing the system model that will be uploaded to a bucket."
  pictureFile: Upload
}

enum SystemModelSortField {
  ID
  HANDLE
  NAME
  PICTURE_URL
}

input SystemModelFilterPictureUrl {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input SystemModelFilterInput {
  and: [SystemModelFilterInput!]

  or: [SystemModelFilterInput!]

  not: [SystemModelFilterInput!]

  id: SystemModelFilterId

  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: SystemModelFilterHandle

  "The display name of the system model."
  name: SystemModelFilterName

  "A URL to a picture representing the system model."
  pictureUrl: SystemModelFilterPictureUrl

  "The list of part numbers associated with the system model."
  partNumbers: SystemModelPartNumberFilterInput

  "The Hardware type associated with the System Model"
  hardwareType: HardwareTypeFilterInput
}

input SystemModelSortInput {
  order: SortOrder
  field: SystemModelSortField!
}

"""
A system model corresponds to what the users thinks as functionally
equivalent devices (e.g. two revisions of a device containing two different
embedded chips but having the same enclosure and the same functionality).
Each SystemModel must be associated to a specific HardwareType.
"""
type SystemModel implements Node {
  id: ID!

  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the system model."
  name: String!

  "A URL to a picture representing the system model."
  pictureUrl: String

  "The list of part numbers associated with the system model."
  partNumbers(
    "How to sort the records in the response"
    sort: [SystemModelPartNumberSortInput]

    "A filter to limit the results"
    filter: SystemModelPartNumberFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [SystemModelPartNumber!]!

  "The Hardware type associated with the System Model"
  hardwareType: HardwareType
}

enum HardwareTypePartNumberSortField {
  ID
  PART_NUMBER
}

input HardwareTypePartNumberFilterPartNumber {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input HardwareTypePartNumberFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input HardwareTypePartNumberFilterInput {
  and: [HardwareTypePartNumberFilterInput!]

  or: [HardwareTypePartNumberFilterInput!]

  not: [HardwareTypePartNumberFilterInput!]

  id: HardwareTypePartNumberFilterId

  "The part number identifier."
  partNumber: HardwareTypePartNumberFilterPartNumber

  hardwareType: HardwareTypeFilterInput
}

input HardwareTypePartNumberSortInput {
  order: SortOrder
  field: HardwareTypePartNumberSortField!
}

type HardwareTypePartNumber {
  id: ID!

  "The part number identifier."
  partNumber: String!

  hardwareType: HardwareType
}

"The result of the :delete_hardware_type mutation"
type DeleteHardwareTypeResult {
  "The record that was successfully deleted"
  result: HardwareType

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

"The result of the :update_hardware_type mutation"
type UpdateHardwareTypeResult {
  "The successful result of the mutation"
  result: HardwareType

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

input UpdateHardwareTypeInput {
  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  "The display name of the hardware type."
  name: String

  "The list of part numbers associated with the hardware type."
  partNumbers: [String!]
}

"The result of the :create_hardware_type mutation"
type CreateHardwareTypeResult {
  "The successful result of the mutation"
  result: HardwareType

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

input CreateHardwareTypeInput {
  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the hardware type."
  name: String!

  partNumbers: [String!]!
}

enum HardwareTypeSortField {
  ID
  HANDLE
  NAME
}

input HardwareTypeFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input HardwareTypeFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input HardwareTypeFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input HardwareTypeFilterInput {
  and: [HardwareTypeFilterInput!]

  or: [HardwareTypeFilterInput!]

  not: [HardwareTypeFilterInput!]

  id: HardwareTypeFilterId

  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: HardwareTypeFilterHandle

  "The display name of the hardware type."
  name: HardwareTypeFilterName

  "The list of part numbers associated with the hardware type."
  partNumbers: HardwareTypePartNumberFilterInput
}

input HardwareTypeSortInput {
  order: SortOrder
  field: HardwareTypeSortField!
}

"""
Denotes a type of hardware that devices can have.

It refers to the physical components embedded in a device.
This can represent, e.g., multiple revisions of a PCB (each with a
different part number) which are functionally equivalent from the device
point of view.
"""
type HardwareType implements Node {
  id: ID!

  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the hardware type."
  name: String!

  "The list of part numbers associated with the hardware type."
  partNumbers(
    "How to sort the records in the response"
    sort: [HardwareTypePartNumberSortInput]

    "A filter to limit the results"
    filter: HardwareTypePartNumberFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [HardwareTypePartNumber!]!
}

"The result of the :update_device mutation"
type UpdateDeviceResult {
  "The successful result of the mutation"
  result: Device

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]
}

input UpdateDeviceInput {
  "The display name of the device."
  name: String
}

enum DeviceSortField {
  ID
  DEVICE_ID
  NAME
  ONLINE
  LAST_CONNECTION
  LAST_DISCONNECTION
  SERIAL_NUMBER
  REALM_ID
  PART_NUMBER
}

input DeviceFilterPartNumber {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceFilterRealmId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input DeviceFilterSerialNumber {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceFilterLastDisconnection {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input DeviceFilterLastConnection {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input DeviceFilterOnline {
  isNil: Boolean
  eq: Boolean
  notEq: Boolean
  in: [Boolean!]
  lessThan: Boolean
  greaterThan: Boolean
  lessThanOrEqual: Boolean
  greaterThanOrEqual: Boolean
}

input DeviceFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceFilterDeviceId {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input DeviceFilterInput {
  and: [DeviceFilterInput!]

  or: [DeviceFilterInput!]

  not: [DeviceFilterInput!]

  id: DeviceFilterId

  "The Astarte device ID of the device."
  deviceId: DeviceFilterDeviceId

  "The display name of the device."
  name: DeviceFilterName

  "Whether the device is connected or not to Astarte"
  online: DeviceFilterOnline

  "The date at which the device last connected to Astarte."
  lastConnection: DeviceFilterLastConnection

  "The date at which the device last disconnected from Astarte."
  lastDisconnection: DeviceFilterLastDisconnection

  "The serial number of the device."
  serialNumber: DeviceFilterSerialNumber

  realmId: DeviceFilterRealmId

  partNumber: DeviceFilterPartNumber

  systemModelPartNumber: SystemModelPartNumberFilterInput

  "The system model of the device"
  systemModel: SystemModelFilterInput
}

input DeviceSortInput {
  order: SortOrder
  field: DeviceSortField!
}

"""
Denotes a device instance that connects and exchanges data.

Each Device is associated to a specific SystemModel, which in turn is
associated to a specific HardwareType.
A Device also exposes info about its connection status and some sets of data read by its operating system.
"""
type Device implements Node {
  id: ID!

  "The Astarte device ID of the device."
  deviceId: String!

  "The display name of the device."
  name: String!

  "Whether the device is connected or not to Astarte"
  online: Boolean!

  "The date at which the device last connected to Astarte."
  lastConnection: DateTime

  "The date at which the device last disconnected from Astarte."
  lastDisconnection: DateTime

  "The serial number of the device."
  serialNumber: String

  realmId: Int

  partNumber: String

  systemModelPartNumber: SystemModelPartNumber

  "The system model of the device"
  systemModel: SystemModel

  cellularConnection: [Modem!]

  baseImage: BaseImageInfo

  batteryStatus: [BatterySlot!]

  hardwareInfo: HardwareInfo

  networkInterfaces: [NetworkInterface!]

  osInfo: OsInfo

  runtimeInfo: RuntimeInfo

  storageUsage: [StorageUnit!]

  systemStatus: SystemStatus

  wifiScanResults: [WifiScanResult!]
}

enum SortOrder {
  DESC
  DESC_NULLS_FIRST
  DESC_NULLS_LAST
  ASC
  ASC_NULLS_FIRST
  ASC_NULLS_LAST
}

"An error generated by a failed mutation"
type MutationError {
  "The human readable error message"
  message: String

  "A shorter error message, with vars not replaced"
  shortMessage: String

  "Replacements for the short message"
  vars: Json

  "An error code for the given error"
  code: String

  "The field or fields that produced the error"
  fields: [String!]
}

type TenantInfo {
  id: ID!

  "The tenant name."
  name: String!

  "The tenant slug."
  slug: String!

  "The default locale supported by the tenant."
  defaultLocale: String!
}

interface Node {
  "The ID of the object."
  id: ID!
}

type RootQueryType {
  "Fetches the list of all base image collections."
  baseImageCollections: [BaseImageCollection!]!

  "Fetches a single base image collection."
  baseImageCollection(
    "The ID of the base image collection."
    id: ID!
  ): BaseImageCollection

  "Fetches a single base image."
  baseImage("The ID of the base image." id: ID!): BaseImage

  """
  Fetches the forwarder config, if available.
  Without a configuration, forwarding functionalities are not available.
  """
  forwarderConfig: ForwarderConfig

  "Fetches a forwarder session by its token and the device ID."
  forwarderSession(
    "The GraphQL ID of the device corresponding to the session."
    deviceId: ID!

    "The token that identifies the session."
    sessionToken: String!
  ): ForwarderSession

  "Fetches the list of all device groups."
  deviceGroups: [DeviceGroup!]!

  "Fetches a single device group."
  deviceGroup("The ID of the device group." id: ID!): DeviceGroup

  "Fetches the list of all device tags."
  existingDeviceTags: [String!]!

  "Fetches the list of all update channels."
  updateChannels: [UpdateChannel!]!

  "Fetches a single update channel."
  updateChannel("The ID of the update channel." id: ID!): UpdateChannel

  "Fetches the list of all update campaigns. Newer update campaigns are returned first."
  updateCampaigns: [UpdateCampaign!]!

  "Fetches a single update campaign."
  updateCampaign("The ID of the update campaign." id: ID!): UpdateCampaign

  node("The ID of an object." id: ID!): Node

  "Retrieves the current tenant."
  tenantInfo: TenantInfo!

  "Returns a single device."
  device("The id of the record" id: ID!): Device

  "Returns a list of devices."
  devices(
    "How to sort the records in the response"
    sort: [DeviceSortInput]

    "A filter to limit the results"
    filter: DeviceFilterInput
  ): [Device!]!

  "Returns a hardware type."
  hardwareType("The id of the record" id: ID!): HardwareType

  "Returns a list of hardware types."
  hardwareTypes(
    "How to sort the records in the response"
    sort: [HardwareTypeSortInput]

    "A filter to limit the results"
    filter: HardwareTypeFilterInput
  ): [HardwareType!]!

  "Returns a system model."
  systemModel("The id of the record" id: ID!): SystemModel

  "Returns a list of system models."
  systemModels(
    "How to sort the records in the response"
    sort: [SystemModelSortInput]

    "A filter to limit the results"
    filter: SystemModelFilterInput
  ): [SystemModel!]!
}

type RootMutationType {
  "Sets led behavior."
  setLedBehavior(input: SetLedBehaviorInput!): SetLedBehaviorPayload

  "Creates a new base image collection."
  createBaseImageCollection(
    input: CreateBaseImageCollectionInput!
  ): CreateBaseImageCollectionPayload

  "Updates a base image collection."
  updateBaseImageCollection(
    input: UpdateBaseImageCollectionInput!
  ): UpdateBaseImageCollectionPayload

  "Deletes a base image collection."
  deleteBaseImageCollection(
    input: DeleteBaseImageCollectionInput!
  ): DeleteBaseImageCollectionPayload

  "Create a new base image in a base image collection."
  createBaseImage(input: CreateBaseImageInput!): CreateBaseImagePayload

  "Updates a base image."
  updateBaseImage(input: UpdateBaseImageInput!): UpdateBaseImagePayload

  "Deletes a base image."
  deleteBaseImage(input: DeleteBaseImageInput!): DeleteBaseImagePayload

  "Requests a forwarder session for the specified device."
  requestForwarderSession(
    input: RequestForwarderSessionInput!
  ): RequestForwarderSessionPayload

  "Creates a new device group."
  createDeviceGroup(input: CreateDeviceGroupInput!): CreateDeviceGroupPayload

  "Updates a device group."
  updateDeviceGroup(input: UpdateDeviceGroupInput!): UpdateDeviceGroupPayload

  "Deletes a device group."
  deleteDeviceGroup(input: DeleteDeviceGroupInput!): DeleteDeviceGroupPayload

  "Initiates an OTA update with a user provided OS image"
  createManualOtaOperation(
    input: CreateManualOtaOperationInput!
  ): CreateManualOtaOperationPayload

  "Creates a new update channel."
  createUpdateChannel(
    input: CreateUpdateChannelInput!
  ): CreateUpdateChannelPayload

  "Updates an update channel."
  updateUpdateChannel(
    input: UpdateUpdateChannelInput!
  ): UpdateUpdateChannelPayload

  "Deletes an update channel."
  deleteUpdateChannel(
    input: DeleteUpdateChannelInput!
  ): DeleteUpdateChannelPayload

  "Creates a new update campaign."
  createUpdateCampaign(
    input: CreateUpdateCampaignInput!
  ): CreateUpdateCampaignPayload

  "Updates a device."
  updateDevice(id: ID!, input: UpdateDeviceInput): UpdateDeviceResult

  "Creates a hardware type."
  createHardwareType(input: CreateHardwareTypeInput!): CreateHardwareTypeResult

  "Updates a hardware type."
  updateHardwareType(
    id: ID!
    input: UpdateHardwareTypeInput
  ): UpdateHardwareTypeResult

  "Deletes a hardware type."
  deleteHardwareType(id: ID!): DeleteHardwareTypeResult

  "Creates a system model."
  createSystemModel(input: CreateSystemModelInput!): CreateSystemModelResult

  "Updates an system model."
  updateSystemModel(
    id: ID!
    input: UpdateSystemModelInput
  ): UpdateSystemModelResult

  "Deletes a system model."
  deleteSystemModel(id: ID!): DeleteSystemModelResult
}

"""
The `Json` scalar type represents arbitrary json string data, represented as UTF-8
character sequences. The Json type is most often used to represent a free-form
human-readable json string.
"""
scalar Json

"""
The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime

"Represents an uploaded file."
scalar Upload

"""
Represents an UpdateChannel.

An UpdateChannel represents a set of TargetGroups that can be targeted in an UpdateCampaign
"""
type UpdateChannel implements Node {
  "The ID of an object"
  id: ID!

  "The display name of the target group."
  name: String!

  "The identifier of the target group."
  handle: String!

  "The DeviceGroups associated with this UpdateChannel"
  targetGroups: [DeviceGroup!]!
}

"An object representing the properties of a Push Rollout Mechanism"
type PushRollout {
  "The maximum percentage of failures allowed over the number of total targets. If the failures exceed this threshold, the Update Campaign terminates with a failure."
  maxFailurePercentage: Float!

  "The maximum number of in progress updates. The Update Campaign will have at most this number of OTA Operations that are started but not yet finished (either successfully or not)."
  maxInProgressUpdates: Int!

  "The number of attempts that have to be tried before giving up on the update of a specific target (and considering it an error). Note that the update is retried only if the OTA Request doesn't get acknowledged from the device."
  otaRequestRetries: Int!

  "The timeout (in seconds) Edgehog has to wait before considering an OTA Request lost (and possibly retry). It must be at least 30 seconds."
  otaRequestTimeoutSeconds: Int!

  "This boolean flag determines if the Base Image will be pushed to the Device even if it already has a greater version of the Base Image."
  forceDowngrade: Boolean!
}

"A Rollout Mechanism used by an Update Campaign"
union RolloutMechanism = PushRollout

"An input object to set the properties of a Push Rollout Mechanism"
input PushRolloutInput {
  "The maximum percentage of failures allowed over the number of total targets. If the failures exceed this threshold, the Update Campaign terminates with a failure."
  maxFailurePercentage: Float!

  "The maximum number of in progress updates. The Update Campaign will have at most this number of OTA Operations that are started but not yet finished (either successfully or not)."
  maxInProgressUpdates: Int!

  """
  The number of attempts that have to be tried before giving up on the update of a specific target (and considering it an error). Note that the update is retried only if the OTA Request doesn't get acknowledged from the device.

  Defaults to 0 if not present.
  """
  otaRequestRetries: Int

  """
  The timeout (in seconds) Edgehog has to wait before considering an OTA Request lost (and possibly retry).

  Defaults to 60 seconds if not present.
  """
  otaRequestTimeoutSeconds: Int

  """
  This boolean flag determines if the Base Image will be pushed to the Device even if it already has a greater version of the Base Image.

  Defaults to false if not present.
  """
  forceDowngrade: Boolean
}

"An input object to provide a Rollout Mechanism"
input RolloutMechanismInput {
  push: PushRolloutInput!
}

"The status of an Update Target"
enum UpdateTargetStatus {
  "The Update Campaign is waiting for the OTA Request to be sent"
  IDLE

  "The Update Target is in progress"
  IN_PROGRESS

  "The Update Target has failed to be updated"
  FAILED

  "The Update Target was successfully updated"
  SUCCESSFUL
}

"""
Represents an UpdateTarget.

An Update Target is the target of an Update Campaign, which is composed by the targeted device and the status of the target in the linked Update Campaign.
"""
type UpdateTarget implements Node {
  "The ID of an object"
  id: ID!

  "The status of the Update Target."
  status: UpdateTargetStatus!

  "The retry count of the Update Target. This indicates how many times Edgehog has tried to send an OTA Update towards the device without receiving an ack."
  retryCount: Int!

  "The timestamp of the latest attempt to update the Update Target"
  latestAttempt: DateTime

  "The timestamp when the Update Target completed its update, either with a success or a failure"
  completionTimestamp: DateTime

  "The Target device."
  device: Device!

  "The OTA Operation that tracks the Update Target in-progress update"
  otaOperation: OtaOperation
}

"The status of an Update Campaign"
enum UpdateCampaignStatus {
  "The Update Campaign has been created but is not being rolled-out yet"
  IDLE

  "The Update Campaign is being rolled-out"
  IN_PROGRESS

  "The Update Campaign has finished"
  FINISHED
}

"The outcome of an Update Campaign"
enum UpdateCampaignOutcome {
  "The Update Campaign has finished succesfully"
  SUCCESS

  "The Update Campaign has finished with a failure"
  FAILURE
}

"""
Represents an UpdateCampaign.

An Update Campaign is the operation that tracks the distribution of a specific Base Image to all devices belonging to an Update Channel.
"""
type UpdateCampaign implements Node {
  "The ID of an object"
  id: ID!

  "The name of the Update Campaign."
  name: String!

  "The status of the Update Campaign."
  status: UpdateCampaignStatus!

  "The outcome of the Update Campaign, present only when it's finished."
  outcome: UpdateCampaignOutcome

  "The Rollout Mechanism used in the Update Campaign."
  rolloutMechanism: RolloutMechanism!

  "The Base Image distributed in the Update Campaign."
  baseImage: BaseImage!

  "The Update Channel targeted by the Update Campaign."
  updateChannel: UpdateChannel!

  "The Targets that will receive the update during the Update Campaign."
  updateTargets: [UpdateTarget!]!

  "The Stats of the Update Campaign"
  stats: UpdateCampaignStats!
}

type UpdateCampaignStats {
  "The total number of targets of the Update Campaign"
  totalTargetCount: Int!

  "The number of targets of the Update Campaign having IDLE status"
  idleTargetCount: Int!

  "The number of targets of the Update Campaign having IN_PROGRESS status"
  inProgressTargetCount: Int!

  "The number of targets of the Update Campaign having FAILED status"
  failedTargetCount: Int!

  "The number of targets of the Update Campaign having SUCCESSFUL status"
  successfulTargetCount: Int!
}

input CreateUpdateChannelInput {
  "The display name of the update channel."
  name: String!

  """
  The identifier of the update channel.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The IDs of the target groups that are targeted by this update channel"
  targetGroupIds: [ID!]!
}

type CreateUpdateChannelPayload {
  "The created update channel."
  updateChannel: UpdateChannel!
}

input UpdateUpdateChannelInput {
  "The ID of the update channel to be updated"
  updateChannelId: ID!

  "The updated display name of the update channel."
  name: String

  """
  The updated identifier of the update channel.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  "The updated IDs of the target groups that are targeted by this update channel"
  targetGroupIds: [ID!]
}

type UpdateUpdateChannelPayload {
  "The updated update channel."
  updateChannel: UpdateChannel!
}

input DeleteUpdateChannelInput {
  "The ID of the update channel to be deleted."
  updateChannelId: ID!
}

type DeleteUpdateChannelPayload {
  "The deleted update channel."
  updateChannel: UpdateChannel!
}

input CreateUpdateCampaignInput {
  "The name of the Update Campaign."
  name: String!

  "The ID of the Base Image that will be distributed in the Update Campaign."
  baseImageId: ID!

  "The ID of the Update Channel that will be targeted by the Update Campaign."
  updateChannelId: ID!

  "The Rollout Mechanism of the Update Campaign, with its properties"
  rolloutMechanism: RolloutMechanismInput!
}

type CreateUpdateCampaignPayload {
  "The created Update Campaign."
  updateCampaign: UpdateCampaign!
}

"Status of the OTA operation."
enum OtaOperationStatus {
  "The OTA operation was created and is waiting an acknowledgment from the device"
  PENDING

  "The OTA operation was acknowledged from the device"
  ACKNOWLEDGED

  "The device is downloading the update"
  DOWNLOADING

  "The device is deploying the update"
  DEPLOYING

  "The device deployed the update"
  DEPLOYED

  "The device is in the process of rebooting"
  REBOOTING

  "A recoverable error happened during the OTA operation"
  ERROR

  "The OTA operation ended with a failure. This is a final state of the OTA Operation"
  FAILURE

  "The OTA operation ended successfully. This is a final state of the OTA Operation"
  SUCCESS
}

"Status code of the OTA operation."
enum OtaOperationStatusCode {
  "The OTA Operation timed out while sending the request to the device"
  REQUEST_TIMEOUT

  "The OTA Operation contained invalid data"
  INVALID_REQUEST

  "An OTA Operation is already in progress on the device"
  UPDATE_ALREADY_IN_PROGRESS

  "A network error was encountered"
  NETWORK_ERROR

  "An IO error was encountered"
  IO_ERROR

  "An internal error was encountered"
  INTERNAL_ERROR

  "The OTA Operation failed due to an invalid base image"
  INVALID_BASE_IMAGE

  "A system rollback has occurred"
  SYSTEM_ROLLBACK

  "The OTA Operation was canceled"
  CANCELED
}

"An OTA update operation"
type OtaOperation implements Node {
  "The ID of an object"
  id: ID!

  "The URL of the base image being installed on the device"
  baseImageUrl: String!

  "The current status of the operation"
  status: OtaOperationStatus!

  "The percentage progress [0-100] for the current status"
  statusProgress: Int!

  "The current status code of the operation"
  statusCode: OtaOperationStatusCode

  "A message with additional details about the current status"
  message: String

  "The device targeted from the operation"
  device: Device!

  "The creation timestamp of the operation"
  createdAt: DateTime!

  "The timestamp of the last update to the operation"
  updatedAt: DateTime!
}

input CreateManualOtaOperationInput {
  "The GraphQL ID (not the Astarte Device ID) of the target device"
  deviceId: ID!

  "An uploaded file of the base image."
  baseImageFile: Upload
}

type CreateManualOtaOperationPayload {
  "The pending OTA operation"
  otaOperation: OtaOperation!
}

"Input object used to provide a localizedText as an input."
input LocalizedTextInput {
  "The locale, expressed in the format indicated in RFC 5646 (e.g. en-US)"
  locale: String!

  "The localized text"
  text: String!
}

type DeviceGroup implements Node {
  "The ID of an object"
  id: ID!

  "The display name of the device group."
  name: String!

  "The handle of the device group."
  handle: String!

  "The selector of the device group."
  selector: String!

  "The devices belonging to the group."
  devices: [Device!]!

  "The UpdateChannel associated with this group, if present."
  updateChannel: UpdateChannel
}

input CreateDeviceGroupInput {
  "The display name of the device group."
  name: String!

  """
  The identifier of the device group.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  """
  The Selector that will determine which devices belong to the device group.

  This must be a valid selector expression, consult the Selector section of the Edgehog documentation for more information about Selectors.
  """
  selector: String!
}

type CreateDeviceGroupPayload {
  "The created device group."
  deviceGroup: DeviceGroup!
}

input UpdateDeviceGroupInput {
  "The ID of the device group to be updated."
  deviceGroupId: ID!

  "The display name of the device group."
  name: String

  """
  The identifier of the device group.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  """
  The Selector that will determine which devices belong to the device group.

  This must be a valid selector expression, consult the Selector section of the Edgehog documentation for more information about Selectors.
  """
  selector: String
}

type UpdateDeviceGroupPayload {
  "The updated device group."
  deviceGroup: DeviceGroup!
}

input DeleteDeviceGroupInput {
  "The ID of the device group to be deleted."
  deviceGroupId: ID!
}

type DeleteDeviceGroupPayload {
  "The deleted device group."
  deviceGroup: DeviceGroup!
}

"The details of a forwarder instance."
type ForwarderConfig {
  "The hostname of the forwarder instance."
  hostname: String!

  "The port of the forwarder instance."
  port: Int!

  "Indicates if TLS should used when connecting to the forwarder."
  secureSessions: Boolean!
}

"The status of a forwarder session"
enum ForwarderSessionStatus {
  "The device is connected to the forwarder."
  CONNECTED

  "The device is connecting to the forwarder."
  CONNECTING
}

"The details of a forwarder session"
type ForwarderSession {
  "The token that identifies the session."
  token: String!

  "The status of the session."
  status: ForwarderSessionStatus!

  "Indicates if TLS is used when the device connects to the forwarder."
  secure: Boolean!

  "The hostname of the forwarder instance."
  forwarderHostname: String!

  "The port of the forwarder instance."
  forwarderPort: Int!
}

input RequestForwarderSessionInput {
  "The GraphQL ID of the device for the requested session."
  deviceId: ID!
}

type RequestForwarderSessionPayload {
  "The token of the requested forwarder session."
  sessionToken: String!
}

"""
Represents a collection of Base Images.

A base image collection represents the collection of all Base Images that can run on a specific System Model.
"""
type BaseImageCollection implements Node {
  "The ID of an object"
  id: ID!

  "The display name of the base image collection."
  name: String!

  "The identifier of the base image collection."
  handle: String!

  "The System Model associated with the Base Image Collection"
  systemModel: SystemModel

  "The Base Images associated with the Base Image Collection"
  baseImages: [BaseImage!]!
}

"""
Represents an uploaded Base Image.

A base image represents a downloadable base image that can be installed on a device
"""
type BaseImage implements Node {
  "The ID of an object"
  id: ID!

  "The base image version"
  version: String!

  "The url where the base image can be downloaded"
  url: String!

  "The starting version requirement for the base image"
  startingVersionRequirement: String

  """
  The localized description of the base image
  The language of the description can be controlled passing an Accept-Language header in the request. If no such header is present, the default tenant language is returned.
  """
  description: String

  """
  The localized release display name of the base image
  The language of the description can be controlled passing an Accept-Language header in the request. If no such header is present, the default tenant language is returned.
  """
  releaseDisplayName: String

  "The Base Image Collection the Base Image belongs to"
  baseImageCollection: BaseImageCollection!
}

input CreateBaseImageCollectionInput {
  "The display name of the base image collection."
  name: String!

  """
  The identifier of the base image collection.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The ID of the system model that is targeted by this base image collection"
  systemModelId: ID!
}

type CreateBaseImageCollectionPayload {
  "The created base image collection."
  baseImageCollection: BaseImageCollection!
}

input UpdateBaseImageCollectionInput {
  "The ID of the base image collection to be updated."
  baseImageCollectionId: ID!

  "The display name of the base image collection."
  name: String

  """
  The identifier of the base image collection.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String
}

type UpdateBaseImageCollectionPayload {
  "The updated base image collection."
  baseImageCollection: BaseImageCollection!
}

input DeleteBaseImageCollectionInput {
  "The ID of the base image collection to be deleted."
  baseImageCollectionId: ID!
}

type DeleteBaseImageCollectionPayload {
  "The deleted base image collection."
  baseImageCollection: BaseImageCollection!
}

input CreateBaseImageInput {
  "The ID of the Base Image Collection this Base Image will belong to"
  baseImageCollectionId: ID!

  "The base image version"
  version: String!

  "The base image file, which will be uploaded to the storage"
  file: Upload!

  "An optional starting version requirement for the base image"
  startingVersionRequirement: String

  "An optional localized description. This description can currently only use the default tenant locale."
  description: LocalizedTextInput

  "An optional relase display name. This can currently only use the default tenant locale."
  releaseDisplayName: LocalizedTextInput
}

type CreateBaseImagePayload {
  "The created base image."
  baseImage: BaseImage!
}

input UpdateBaseImageInput {
  "The ID of the base image to be updated."
  baseImageId: ID!

  "The starting version requirement for the base image"
  startingVersionRequirement: String

  "The localized description. This description can currently only use the default tenant locale."
  description: LocalizedTextInput

  "The localized relase display name. This can currently only use the default tenant locale."
  releaseDisplayName: LocalizedTextInput
}

type UpdateBaseImagePayload {
  "The updated base image."
  baseImage: BaseImage!
}

input DeleteBaseImageInput {
  "The ID of the base image to be deleted."
  baseImageId: ID!
}

type DeleteBaseImagePayload {
  "The deleted base image."
  baseImage: BaseImage!
}

"""
Describes hardware-related info of a device.

It exposes data read by a device's operating system about the underlying hardware.
"""
type HardwareInfo {
  "The architecture of the CPU."
  cpuArchitecture: String

  "The reference code of the CPU model."
  cpuModel: String

  "The display name of the CPU model."
  cpuModelName: String

  "The vendor's name."
  cpuVendor: String

  "The Bytes count of memory."
  memoryTotalBytes: Int
}

"Describes the current usage of a storage unit on a device."
type StorageUnit {
  "The label of the storage unit."
  label: String!

  "The total number of bytes of the storage unit."
  totalBytes: Int

  "The number of free bytes of the storage unit."
  freeBytes: Int
}

"Describes the information on the system's base image for a device."
type BaseImageInfo {
  "The name of the image."
  name: String

  "The version of the image."
  version: String

  "Human readable build identifier of the image."
  buildId: String

  "A unique string that identifies the release, usually the image hash."
  fingerprint: String
}

"Describes an operating system of a device."
type OsInfo {
  "The name of the operating system."
  name: String

  "The version of the operating system."
  version: String
}

"Describes the current status of the operating system of a device."
type SystemStatus {
  "The identifier of the performed boot sequence."
  bootId: String

  "The number of free bytes of memory."
  memoryFreeBytes: Int

  "The number of running tasks on the system."
  taskCount: Int

  "The number of milliseconds since the last system boot."
  uptimeMilliseconds: Int

  "The date at which the system status was read."
  timestamp: DateTime!
}

"Describes the list of WiFi Access Points found by the device."
type WifiScanResult {
  "The channel used by the Access Point."
  channel: Int

  "Indicates whether the device is connected to the Access Point."
  connected: Boolean

  "The ESSID advertised by the Access Point."
  essid: String

  "The MAC address advertised by the Access Point."
  macAddress: String

  "The power of the radio signal, measured in dBm."
  rssi: Int

  "The date at which the device found the Access Point."
  timestamp: DateTime!
}

"The current status of the battery."
enum BatteryStatus {
  "The battery is charging."
  CHARGING

  "The battery is discharging."
  DISCHARGING

  "The battery is idle."
  IDLE

  "The battery is either in a charging or in an idle state, since the hardware doesn't allow to distinguish between them."
  EITHER_IDLE_OR_CHARGING

  "The battery is in a failed state."
  FAILURE

  "The battery is removed."
  REMOVED

  "The battery status cannot be determined."
  UNKNOWN
}

"Describes a battery slot of a device."
type BatterySlot {
  "The identifier of the battery slot."
  slot: String!

  "Battery level estimated percentage [0.0%-100.0%]"
  levelPercentage: Float

  "Battery level measurement absolute error [0.0-100.0]"
  levelAbsoluteError: Float

  "The current status of the battery."
  status: BatteryStatus
}

"The current GSM/LTE registration status of the modem."
enum ModemRegistrationStatus {
  "Not registered, modem is not currently searching a new operator to register to."
  NOT_REGISTERED

  "Registered, home network."
  REGISTERED

  "Not registered, but modem is currently searching a new operator to register to."
  SEARCHING_OPERATOR

  "Registration denied."
  REGISTRATION_DENIED

  "Unknown (e.g. out of GERAN/UTRAN/E-UTRAN coverage)."
  UNKNOWN

  "Registered, roaming."
  REGISTERED_ROAMING
}

"The current access technology of the serving cell."
enum ModemTechnology {
  "GSM."
  GSM

  "GSM Compact."
  GSM_COMPACT

  "UTRAN."
  UTRAN

  "GSM with EGPRS."
  GSM_EGPRS

  "UTRAN with HSDPA."
  UTRAN_HSDPA

  "UTRAN with HSUPA."
  UTRAN_HSUPA

  "UTRAN with HSDPA and HSUPA."
  UTRAN_HSDPA_HSUPA

  "E-UTRAN."
  EUTRAN
}

"Describes a modem of a device."
type Modem {
  "The identifier of the modem."
  slot: String!

  "The operator apn address."
  apn: String

  "The modem IMEI code."
  imei: String

  "The SIM IMSI code."
  imsi: String

  "Carrier operator name."
  carrier: String

  "Unique identifier of the cell."
  cellId: Int

  "The cell tower's Mobile Country Code (MCC)."
  mobileCountryCode: Int

  "The cell tower's Mobile Network Code."
  mobileNetworkCode: Int

  "The Local Area Code."
  localAreaCode: Int

  "The current registration status of the modem."
  registrationStatus: ModemRegistrationStatus

  "Signal strength in dBm."
  rssi: Float

  "Access Technology"
  technology: ModemTechnology
}

"The connection technology of the network interface."
enum NetworkInterfaceTechnology {
  "Ethernet."
  ETHERNET

  "Bluetooth."
  BLUETOOTH

  "Cellular."
  CELLULAR

  "WiFi."
  WIFI
}

"Describes a network interface of a device."
type NetworkInterface {
  "The identifier of the network interface."
  name: String!

  "The normalized physical address."
  macAddress: String

  "Connection Technology"
  technology: NetworkInterfaceTechnology
}

"Describes an Edgehog runtime."
type RuntimeInfo {
  "The name of the Edgehog runtime."
  name: String

  "The version of the Edgehog runtime."
  version: String

  "The environment of the Edgehog runtime."
  environment: String

  "The URL that uniquely identifies the Edgehog runtime implementation."
  url: String
}

"Led behavior"
enum LedBehavior {
  "Blink for 60 seconds."
  BLINK

  "Double blink for 60 seconds."
  DOUBLE_BLINK

  "Slow blink for 60 seconds."
  SLOW_BLINK
}

input SetLedBehaviorInput {
  "The GraphQL ID (not the Astarte Device ID) of the target device"
  deviceId: ID!

  "The led behavior"
  behavior: LedBehavior!
}

type SetLedBehaviorPayload {
  "The resulting led behavior."
  behavior: LedBehavior!
}
