schema {
  mutation: RootMutationType
  query: RootQueryType
}

input UpdateCampaignRolloutMechanismPushInput {
  "This boolean flag determines if the Base Image will be pushed to the Device even if it already has a greater version of the Base Image."
  forceDowngrade: Boolean

  "The maximum percentage of failures allowed over the number of total targets. If the failures exceed this threshold, the Update Campaign terminates with a failure."
  maxFailurePercentage: Float

  "The maximum number of in progress updates. The Update Campaign will have at most this number of OTA Operations that are started but not yet finished (either successfully or not)."
  maxInProgressUpdates: Int

  "The number of attempts that have to be tried before giving up on the update of a specific target (and considering it an error). Note that the update is retried only if the OTA Request doesn't get acknowledged from the device."
  otaRequestRetries: Int

  "The timeout (in seconds) Edgehog has to wait before considering an OTA Request lost (and possibly retry). It must be at least 30 seconds."
  otaRequestTimeoutSeconds: Int
}

"An object representing the properties of a Push Rollout Mechanism."
type PushRollout {
  "This boolean flag determines if the Base Image will be pushed to the Device even if it already has a greater version of the Base Image."
  forceDowngrade: Boolean!

  "The maximum percentage of failures allowed over the number of total targets. If the failures exceed this threshold, the Update Campaign terminates with a failure."
  maxFailurePercentage: Float!

  "The maximum number of in progress updates. The Update Campaign will have at most this number of OTA Operations that are started but not yet finished (either successfully or not)."
  maxInProgressUpdates: Int!

  "The number of attempts that have to be tried before giving up on the update of a specific target (and considering it an error). Note that the update is retried only if the OTA Request doesn't get acknowledged from the device."
  otaRequestRetries: Int!

  "The timeout (in seconds) Edgehog has to wait before considering an OTA Request lost (and possibly retry). It must be at least 30 seconds."
  otaRequestTimeoutSeconds: Int!
}

"Describes a modem of a device."
type Modem {
  "The operator apn address."
  apn: String

  "Carrier operator name."
  carrier: String

  "Unique identifier of the cell."
  cellId: Int

  "The modem IMEI code."
  imei: String

  "The SIM IMSI code."
  imsi: String

  "The Local Area Code."
  localAreaCode: Int

  "The cell tower's Mobile Country Code (MCC)."
  mobileCountryCode: Int

  "The cell tower's Mobile Network Code."
  mobileNetworkCode: Int

  "The GSM/LTE registration status of the modem."
  registrationStatus: ModemRegistrationStatus

  "Signal strength in dBm."
  rssi: Float

  "The identifier of the modem."
  slot: String!

  "The access technology of the serving cell."
  technology: ModemTechnology
}

"Describes a battery slot of a device."
type BatterySlot {
  "Battery level measurement absolute error [0.0-100.0]."
  levelAbsoluteError: Float

  "Battery level estimated percentage [0.0%-100.0%]."
  levelPercentage: Float

  "The identifier of the battery slot."
  slot: String!

  "The current status of the battery."
  status: BatterySlotStatus
}

"""
Describes the place where a device is located.

The field holds information about the device's address, which is
estimated by means of Edgehog's geolocation modules and the data
published by the device.
"""
type Location {
  "The formatted address associated with the location."
  formattedAddress: String!

  "The date and time at which the location was measured."
  timestamp: DateTime!

  "Describes how the location was calculated."
  source: String
}

"Describes a network interface of a device."
type NetworkInterface {
  "The identifier of the network interface."
  name: String!

  "The normalized physical address."
  macAddress: String

  "The connection technology."
  technology: NetworkInterfaceTechnology
}

"""
Describes the position of a device.

The field holds information about the GPS coordinates of the device,
which are estimated by means of Edgehog's geolocation modules and the
data published by the device.
"""
type Position {
  "The latitude coordinate."
  latitude: Float!

  "The longitude coordinate."
  longitude: Float!

  "The accuracy of the measurement, in meters."
  accuracy: Float

  "The altitude coordinate."
  altitude: Float

  "The accuracy of the altitude measurement, in meters."
  altitudeAccuracy: Float

  "The measured heading."
  heading: Float

  "The measured speed."
  speed: Float

  "The date and time at which the measurement was made."
  timestamp: DateTime!

  "Describes how the position was calculated."
  source: String
}

input RolloutMechanismInput {
  push: UpdateCampaignRolloutMechanismPushInput
}

union RolloutMechanism = PushRollout

enum UpdateTargetStatus {
  "The update campaign is waiting for the OTA Request to be sent."
  IDLE

  "The update target is in progress."
  IN_PROGRESS

  "The update target has failed to be updated."
  FAILED

  "The update target was successfully updated."
  SUCCESSFUL
}

enum UpdateCampaignStatus {
  "The update campaign has been created but is not being rolled-out yet."
  IDLE

  "The update campaign is being rolled-out."
  IN_PROGRESS

  "The update campaign has finished."
  FINISHED
}

enum UpdateCampaignOutcome {
  "The update campaign has finished succesfully."
  SUCCESS

  "The update campaign has finished with a failure."
  FAILURE
}

enum OtaOperationStatus {
  "The OTA operation was created and is waiting an acknowledgment from the device"
  PENDING

  "The OTA operation was acknowledged from the device"
  ACKNOWLEDGED

  "The device is downloading the update"
  DOWNLOADING

  "The device is deploying the update"
  DEPLOYING

  "The device deployed the update"
  DEPLOYED

  "The device is in the process of rebooting"
  REBOOTING

  "A recoverable error happened during the OTA operation"
  ERROR

  "The OTA operation ended with a failure. This is a final state of the OTA Operation"
  FAILURE

  "The OTA operation ended successfully. This is a final state of the OTA Operation"
  SUCCESS
}

enum OtaOperationStatusCode {
  "The OTA Operation timed out while sending the request to the device"
  REQUEST_TIMEOUT

  "The OTA Operation contained invalid data"
  INVALID_REQUEST

  "An OTA Operation is already in progress on the device"
  UPDATE_ALREADY_IN_PROGRESS

  "A network error was encountered"
  NETWORK_ERROR

  "An IO error was encountered"
  IO_ERROR

  "An internal error was encountered"
  INTERNAL_ERROR

  "The OTA Operation failed due to an invalid base image"
  INVALID_BASE_IMAGE

  "A system rollback has occurred"
  SYSTEM_ROLLBACK

  "The OTA Operation was canceled"
  CANCELED
}

enum ForwarderSessionStatus {
  "The device is connected to the forwarder."
  CONNECTED

  "The device is connecting to the forwarder."
  CONNECTING
}

enum DeviceLedBehavior {
  "Blink for 60 seconds."
  BLINK

  "Double blink for 60 seconds."
  DOUBLE_BLINK

  "Slow blink for 60 seconds."
  SLOW_BLINK
}

enum DeviceCapability {
  "The device provides information about its base image."
  BASE_IMAGE

  "The device provides information about its battery status."
  BATTERY_STATUS

  "The device provides information about its cellular connection."
  CELLULAR_CONNECTION

  "The device supports commands, for example the rebooting command."
  COMMANDS

  "The device can be geolocated."
  GEOLOCATION

  "The device provides information about its hardware."
  HARDWARE_INFO

  "The device can be asked to blink its LED in a specific pattern."
  LED_BEHAVIORS

  "The device can provide information about its network interfaces."
  NETWORK_INTERFACE_INFO

  "The device provides information about its operating system."
  OPERATING_SYSTEM

  "The device supports remote terminal sessions."
  REMOTE_TERMINAL

  "The device provides information about its runtime."
  RUNTIME_INFO

  "The device can be updated remotely."
  SOFTWARE_UPDATES

  "The device provides information about its storage units."
  STORAGE

  "The device provides information about its system."
  SYSTEM_INFO

  "The device provides information about its system status."
  SYSTEM_STATUS

  "The device telemetry can be configured."
  TELEMETRY_CONFIG

  "The device provides information about surrounding WiFi APs."
  WIFI
}

enum ModemRegistrationStatus {
  "Not registered, modem is not currently searching a new operator to register to."
  NOT_REGISTERED

  "Registered, home network."
  REGISTERED

  "Not registered, but modem is currently searching a new operator to register to."
  SEARCHING_OPERATOR

  "Registration denied."
  REGISTRATION_DENIED

  "Unknown (e.g. out of GERAN/UTRAN/E-UTRAN coverage)."
  UNKNOWN

  "Registered, roaming."
  REGISTERED_ROAMING
}

enum ModemTechnology {
  "GSM."
  GSM

  "GSM Compact."
  GSM_COMPACT

  "UTRAN."
  UTRAN

  "GSM with EGPRS."
  GSM_EGPRS

  "UTRAN with HSDPA."
  UTRAN_HSDPA

  "UTRAN with HSUPA."
  UTRAN_HSUPA

  "UTRAN with HSDPA and HSUPA."
  UTRAN_HSDPA_HSUPA

  "E-UTRAN."
  EUTRAN
}

enum BatterySlotStatus {
  "The battery is charging."
  CHARGING

  "The battery is discharging."
  DISCHARGING

  "The battery is idle."
  IDLE

  "The battery is either in a charging or in an idle state, since the hardware doesn't allow to distinguish between them."
  EITHER_IDLE_OR_CHARGING

  "The battery is in a failed state."
  FAILURE

  "The battery is removed."
  REMOVED

  "The battery status cannot be determined."
  UNKNOWN
}

enum NetworkInterfaceTechnology {
  "Ethernet."
  ETHERNET

  "Bluetooth."
  BLUETOOTH

  "Cellular."
  CELLULAR

  "WiFi."
  WIFI
}

input LocalizedAttributeUpdateInput {
  value: String
  languageTag: String!
}

input LocalizedAttributeInput {
  value: String!
  languageTag: String!
}

type LocalizedAttribute {
  value: String!
  languageTag: String!
}

"The result of the :delete_base_image_collection mutation"
type DeleteBaseImageCollectionResult {
  "The record that was successfully deleted"
  result: BaseImageCollection

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_base_image_collection mutation"
type UpdateBaseImageCollectionResult {
  "The successful result of the mutation"
  result: BaseImageCollection

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateBaseImageCollectionInput {
  "The display name of the base image collection."
  name: String

  """
  The identifier of the base image collection.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String
}

"The result of the :create_base_image_collection mutation"
type CreateBaseImageCollectionResult {
  "The successful result of the mutation"
  result: BaseImageCollection

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateBaseImageCollectionInput {
  "The display name of the base image collection."
  name: String!

  """
  The identifier of the base image collection.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The ID of the system model that is targeted by the base image collection"
  systemModelId: ID!
}

enum BaseImageCollectionSortField {
  ID
  NAME
  HANDLE
}

":base_image_collection connection"
type BaseImageCollectionConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":base_image_collection edges"
  edges: [BaseImageCollectionEdge!]
}

":base_image_collection edge"
type BaseImageCollectionEdge {
  "Cursor"
  cursor: String!

  ":base_image_collection node"
  node: BaseImageCollection!
}

input BaseImageCollectionFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input BaseImageCollectionFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input BaseImageCollectionFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input BaseImageCollectionFilterInput {
  and: [BaseImageCollectionFilterInput!]

  or: [BaseImageCollectionFilterInput!]

  not: [BaseImageCollectionFilterInput!]

  id: BaseImageCollectionFilterId

  "The display name of the base image collection."
  name: BaseImageCollectionFilterName

  """
  The identifier of the base image collection.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: BaseImageCollectionFilterHandle

  "The system model associated with the base image collection."
  systemModel: SystemModelFilterInput

  "The base images associated with the base image collection."
  baseImages: BaseImageFilterInput
}

input BaseImageCollectionSortInput {
  order: SortOrder
  field: BaseImageCollectionSortField!
}

"""
Represents a collection of Base Images.

A base image collection represents the collection of all Base Images that can run on a specific System Model.
"""
type BaseImageCollection implements Node {
  id: ID!

  "The display name of the base image collection."
  name: String!

  """
  The identifier of the base image collection.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The system model associated with the base image collection."
  systemModel: SystemModel!

  "The base images associated with the base image collection."
  baseImages(
    "How to sort the records in the response"
    sort: [BaseImageSortInput]

    "A filter to limit the results"
    filter: BaseImageFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): BaseImageConnection!
}

"The result of the :delete_base_image mutation"
type DeleteBaseImageResult {
  "The record that was successfully deleted"
  result: BaseImage

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_base_image mutation"
type UpdateBaseImageResult {
  "The successful result of the mutation"
  result: BaseImage

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateBaseImageInput {
  "The starting version requirement for the base image."
  startingVersionRequirement: String

  "A list of descriptions in different languages."
  localizedDescriptions: [LocalizedAttributeUpdateInput!]

  "A list of release display names in different languages."
  localizedReleaseDisplayNames: [LocalizedAttributeUpdateInput!]
}

"The result of the :create_base_image mutation"
type CreateBaseImageResult {
  "The successful result of the mutation"
  result: BaseImage

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateBaseImageInput {
  "The base image version."
  version: String!

  "The starting version requirement for the base image."
  startingVersionRequirement: String

  "The ID of the base image collection this base image will belong to."
  baseImageCollectionId: ID!

  "The base image file, which will be uploaded to the storage."
  file: Upload!

  "A list of descriptions in different languages."
  localizedDescriptions: [LocalizedAttributeInput!]

  "A list of release display names in different languages."
  localizedReleaseDisplayNames: [LocalizedAttributeInput!]
}

enum BaseImageSortField {
  ID
  VERSION
  STARTING_VERSION_REQUIREMENT
  URL
}

":base_image connection"
type BaseImageConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":base_image edges"
  edges: [BaseImageEdge!]
}

":base_image edge"
type BaseImageEdge {
  "Cursor"
  cursor: String!

  ":base_image node"
  node: BaseImage!
}

input BaseImageFilterUrl {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input BaseImageFilterStartingVersionRequirement {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input BaseImageFilterVersion {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input BaseImageFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input BaseImageFilterInput {
  and: [BaseImageFilterInput!]

  or: [BaseImageFilterInput!]

  not: [BaseImageFilterInput!]

  id: BaseImageFilterId

  "The base image version."
  version: BaseImageFilterVersion

  "The starting version requirement for the base image."
  startingVersionRequirement: BaseImageFilterStartingVersionRequirement

  "The url where the base image can be downloaded."
  url: BaseImageFilterUrl

  "The base image collection that this base image belongs to."
  baseImageCollection: BaseImageCollectionFilterInput
}

input BaseImageSortInput {
  order: SortOrder
  field: BaseImageSortField!
}

"""
Represents an uploaded Base Image.

A base image represents a downloadable base image that can be installed on a device
"""
type BaseImage implements Node {
  id: ID!

  "The base image version."
  version: String!

  "The starting version requirement for the base image."
  startingVersionRequirement: String

  "The url where the base image can be downloaded."
  url: String!

  "The base image collection that this base image belongs to."
  baseImageCollection: BaseImageCollection!

  "A list of descriptions in different languages."
  localizedDescriptions(preferredLanguageTags: [String!]): [LocalizedAttribute!]

  "A list of release display names in different languages."
  localizedReleaseDisplayNames(
    preferredLanguageTags: [String!]
  ): [LocalizedAttribute!]
}

"A relay page info"
type PageInfo {
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!

  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!

  "When paginating backwards, the cursor to continue"
  startCursor: String

  "When paginating forwards, the cursor to continue"
  endCursor: String
}

"A relay node"
interface Node {
  "A unique identifier"
  id: ID!
}

enum SortOrder {
  DESC
  DESC_NULLS_FIRST
  DESC_NULLS_LAST
  ASC
  ASC_NULLS_FIRST
  ASC_NULLS_LAST
}

"An error generated by a failed mutation"
type MutationError {
  "The human readable error message"
  message: String

  "A shorter error message, with vars not replaced"
  shortMessage: String

  "Replacements for the short message"
  vars: Json

  "An error code for the given error"
  code: String

  "The field or fields that produced the error"
  fields: [String!]
}

enum SystemModelPartNumberSortField {
  ID
  PART_NUMBER
}

":system_model_part_number connection"
type SystemModelPartNumberConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":system_model_part_number edges"
  edges: [SystemModelPartNumberEdge!]
}

":system_model_part_number edge"
type SystemModelPartNumberEdge {
  "Cursor"
  cursor: String!

  ":system_model_part_number node"
  node: SystemModelPartNumber!
}

input SystemModelPartNumberFilterPartNumber {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelPartNumberFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input SystemModelPartNumberFilterInput {
  and: [SystemModelPartNumberFilterInput!]

  or: [SystemModelPartNumberFilterInput!]

  not: [SystemModelPartNumberFilterInput!]

  id: SystemModelPartNumberFilterId

  "The part number identifier."
  partNumber: SystemModelPartNumberFilterPartNumber

  systemModel: SystemModelFilterInput
}

input SystemModelPartNumberSortInput {
  order: SortOrder
  field: SystemModelPartNumberSortField!
}

type SystemModelPartNumber {
  id: ID!

  "The part number identifier."
  partNumber: String!

  systemModel: SystemModel
}

"The result of the :delete_system_model mutation"
type DeleteSystemModelResult {
  "The record that was successfully deleted"
  result: SystemModel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_system_model mutation"
type UpdateSystemModelResult {
  "The successful result of the mutation"
  result: SystemModel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateSystemModelInput {
  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  "The display name of the system model."
  name: String

  "A URL to a picture representing the system model."
  pictureUrl: String

  "The list of part numbers associated with the system model."
  partNumbers: [String!]

  "A picture representing the system model that will be uploaded to a bucket."
  pictureFile: Upload

  """
  A list of descriptions in different languages.

  If a language already exists it is updated. If a null value is passed, the language
  is deleted.
  """
  localizedDescriptions: [LocalizedAttributeUpdateInput!]
}

"The result of the :create_system_model mutation"
type CreateSystemModelResult {
  "The successful result of the mutation"
  result: SystemModel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateSystemModelInput {
  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the system model."
  name: String!

  "A URL to a picture representing the system model."
  pictureUrl: String

  "The ID of the hardware type that can be used by devices of this model"
  hardwareTypeId: ID!

  "The list of part numbers associated with the system model."
  partNumbers: [String!]!

  "A picture representing the system model that will be uploaded to a bucket."
  pictureFile: Upload

  "A list of descriptions in different languages."
  localizedDescriptions: [LocalizedAttributeInput!]
}

enum SystemModelSortField {
  ID
  HANDLE
  NAME
  PICTURE_URL
}

":system_model connection"
type SystemModelConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":system_model edges"
  edges: [SystemModelEdge!]
}

":system_model edge"
type SystemModelEdge {
  "Cursor"
  cursor: String!

  ":system_model node"
  node: SystemModel!
}

input SystemModelFilterPictureUrl {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input SystemModelFilterInput {
  and: [SystemModelFilterInput!]

  or: [SystemModelFilterInput!]

  not: [SystemModelFilterInput!]

  id: SystemModelFilterId

  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: SystemModelFilterHandle

  "The display name of the system model."
  name: SystemModelFilterName

  "A URL to a picture representing the system model."
  pictureUrl: SystemModelFilterPictureUrl

  "The list of part numbers associated with the system model."
  partNumbers: SystemModelPartNumberFilterInput

  "The Hardware type associated with the System Model"
  hardwareType: HardwareTypeFilterInput
}

input SystemModelSortInput {
  order: SortOrder
  field: SystemModelSortField!
}

"""
A system model corresponds to what the users thinks as functionally
equivalent devices (e.g. two revisions of a device containing two different
embedded chips but having the same enclosure and the same functionality).
Each SystemModel must be associated to a specific HardwareType.
"""
type SystemModel implements Node {
  id: ID!

  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the system model."
  name: String!

  "A URL to a picture representing the system model."
  pictureUrl: String

  "The list of part numbers associated with the system model."
  partNumbers(
    "How to sort the records in the response"
    sort: [SystemModelPartNumberSortInput]

    "A filter to limit the results"
    filter: SystemModelPartNumberFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): SystemModelPartNumberConnection!

  "The Hardware type associated with the System Model"
  hardwareType: HardwareType

  "A list of descriptions in different languages."
  localizedDescriptions(preferredLanguageTags: [String!]): [LocalizedAttribute!]
}

enum HardwareTypePartNumberSortField {
  ID
  PART_NUMBER
}

":hardware_type_part_number connection"
type HardwareTypePartNumberConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":hardware_type_part_number edges"
  edges: [HardwareTypePartNumberEdge!]
}

":hardware_type_part_number edge"
type HardwareTypePartNumberEdge {
  "Cursor"
  cursor: String!

  ":hardware_type_part_number node"
  node: HardwareTypePartNumber!
}

input HardwareTypePartNumberFilterPartNumber {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input HardwareTypePartNumberFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input HardwareTypePartNumberFilterInput {
  and: [HardwareTypePartNumberFilterInput!]

  or: [HardwareTypePartNumberFilterInput!]

  not: [HardwareTypePartNumberFilterInput!]

  id: HardwareTypePartNumberFilterId

  "The part number identifier."
  partNumber: HardwareTypePartNumberFilterPartNumber

  hardwareType: HardwareTypeFilterInput
}

input HardwareTypePartNumberSortInput {
  order: SortOrder
  field: HardwareTypePartNumberSortField!
}

type HardwareTypePartNumber {
  id: ID!

  "The part number identifier."
  partNumber: String!

  hardwareType: HardwareType
}

"The result of the :delete_hardware_type mutation"
type DeleteHardwareTypeResult {
  "The record that was successfully deleted"
  result: HardwareType

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_hardware_type mutation"
type UpdateHardwareTypeResult {
  "The successful result of the mutation"
  result: HardwareType

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateHardwareTypeInput {
  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  "The display name of the hardware type."
  name: String

  "The list of part numbers associated with the hardware type."
  partNumbers: [String!]
}

"The result of the :create_hardware_type mutation"
type CreateHardwareTypeResult {
  "The successful result of the mutation"
  result: HardwareType

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateHardwareTypeInput {
  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the hardware type."
  name: String!

  partNumbers: [String!]!
}

enum HardwareTypeSortField {
  ID
  HANDLE
  NAME
}

":hardware_type connection"
type HardwareTypeConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":hardware_type edges"
  edges: [HardwareTypeEdge!]
}

":hardware_type edge"
type HardwareTypeEdge {
  "Cursor"
  cursor: String!

  ":hardware_type node"
  node: HardwareType!
}

input HardwareTypeFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input HardwareTypeFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input HardwareTypeFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input HardwareTypeFilterInput {
  and: [HardwareTypeFilterInput!]

  or: [HardwareTypeFilterInput!]

  not: [HardwareTypeFilterInput!]

  id: HardwareTypeFilterId

  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: HardwareTypeFilterHandle

  "The display name of the hardware type."
  name: HardwareTypeFilterName

  "The list of part numbers associated with the hardware type."
  partNumbers: HardwareTypePartNumberFilterInput
}

input HardwareTypeSortInput {
  order: SortOrder
  field: HardwareTypeSortField!
}

"""
Denotes a type of hardware that devices can have.

It refers to the physical components embedded in a device.
This can represent, e.g., multiple revisions of a PCB (each with a
different part number) which are functionally equivalent from the device
point of view.
"""
type HardwareType implements Node {
  id: ID!

  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the hardware type."
  name: String!

  "The list of part numbers associated with the hardware type."
  partNumbers(
    "How to sort the records in the response"
    sort: [HardwareTypePartNumberSortInput]

    "A filter to limit the results"
    filter: HardwareTypePartNumberFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): HardwareTypePartNumberConnection!
}

"The result of the :set_device_led_behavior mutation"
type SetDeviceLedBehaviorResult {
  "The successful result of the mutation"
  result: Device

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input SetDeviceLedBehaviorInput {
  "The led behavior."
  behavior: DeviceLedBehavior!
}

"The result of the :remove_device_tags mutation"
type RemoveDeviceTagsResult {
  "The successful result of the mutation"
  result: Device

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input RemoveDeviceTagsInput {
  tags: [String!]!
}

"The result of the :add_device_tags mutation"
type AddDeviceTagsResult {
  "The successful result of the mutation"
  result: Device

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input AddDeviceTagsInput {
  tags: [String!]!
}

"The result of the :update_device mutation"
type UpdateDeviceResult {
  "The successful result of the mutation"
  result: Device

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateDeviceInput {
  "The display name of the device."
  name: String
}

enum DeviceSortField {
  ID
  DEVICE_ID
  NAME
  ONLINE
  LAST_CONNECTION
  LAST_DISCONNECTION
  SERIAL_NUMBER
}

":device connection"
type DeviceConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":device edges"
  edges: [DeviceEdge!]
}

":device edge"
type DeviceEdge {
  "Cursor"
  cursor: String!

  ":device node"
  node: Device!
}

input DeviceFilterSerialNumber {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceFilterLastDisconnection {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input DeviceFilterLastConnection {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input DeviceFilterOnline {
  isNil: Boolean
  eq: Boolean
  notEq: Boolean
  in: [Boolean!]
  lessThan: Boolean
  greaterThan: Boolean
  lessThanOrEqual: Boolean
  greaterThanOrEqual: Boolean
}

input DeviceFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceFilterDeviceId {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input DeviceFilterInput {
  and: [DeviceFilterInput!]

  or: [DeviceFilterInput!]

  not: [DeviceFilterInput!]

  id: DeviceFilterId

  "The Astarte device ID of the device."
  deviceId: DeviceFilterDeviceId

  "The display name of the device."
  name: DeviceFilterName

  "Whether the device is connected or not to Astarte"
  online: DeviceFilterOnline

  "The date at which the device last connected to Astarte."
  lastConnection: DeviceFilterLastConnection

  "The date at which the device last disconnected from Astarte."
  lastDisconnection: DeviceFilterLastDisconnection

  "The serial number of the device."
  serialNumber: DeviceFilterSerialNumber

  "The system model of the device"
  systemModel: SystemModelFilterInput

  "The tags of the device"
  tags: TagFilterInput

  "The groups the device belongs to."
  deviceGroups: DeviceGroupFilterInput

  "The existing OTA operations for this device"
  otaOperations: OtaOperationFilterInput
}

input DeviceSortInput {
  order: SortOrder
  field: DeviceSortField!
}

"""
Denotes a device instance that connects and exchanges data.

Each Device is associated to a specific SystemModel, which in turn is
associated to a specific HardwareType.
A Device also exposes info about its connection status and some sets of data read by its operating system.
"""
type Device implements Node {
  id: ID!

  "The Astarte device ID of the device."
  deviceId: String!

  "The display name of the device."
  name: String!

  "Whether the device is connected or not to Astarte"
  online: Boolean!

  "The date at which the device last connected to Astarte."
  lastConnection: DateTime

  "The date at which the device last disconnected from Astarte."
  lastDisconnection: DateTime

  "The serial number of the device."
  serialNumber: String

  "The system model of the device"
  systemModel: SystemModel

  "The tags of the device"
  tags(
    "How to sort the records in the response"
    sort: [TagSortInput]

    "A filter to limit the results"
    filter: TagFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): TagConnection!

  "The groups the device belongs to."
  deviceGroups(
    "How to sort the records in the response"
    sort: [DeviceGroupSortInput]

    "A filter to limit the results"
    filter: DeviceGroupFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [DeviceGroup!]!

  "The existing OTA operations for this device"
  otaOperations(
    "How to sort the records in the response"
    sort: [OtaOperationSortInput]

    "A filter to limit the results"
    filter: OtaOperationFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): OtaOperationConnection!

  "The capabilities that the device can support."
  capabilities: [DeviceCapability!]!

  cellularConnection: [Modem!]

  baseImage: BaseImageInfo

  batteryStatus: [BatterySlot!]

  hardwareInfo: HardwareInfo

  """
  Describes the place where the device is located.

  The field holds information about the device's address, which is
  estimated by means of Edgehog's geolocation modules and the data
  published by the device.
  """
  location: Location

  networkInterfaces: [NetworkInterface!]

  osInfo: OsInfo

  """
  Describes the position of a device.

  The field holds information about the GPS coordinates of the device,
  which are estimated by means of Edgehog's geolocation modules and the
  data published by the device.
  """
  position: Position

  runtimeInfo: RuntimeInfo

  storageUsage: [StorageUnit!]

  systemStatus: SystemStatus

  wifiScanResults: [WifiScanResult!]
}

input RequestForwarderSessionInput {
  deviceId: ID!
}

"The details of a forwarder session."
type ForwarderSession {
  "The token that identifies the session."
  id: ID!

  "The token that identifies the session."
  token: String!

  "The status of the session."
  status: ForwarderSessionStatus!

  "The hostname of the forwarder instance."
  forwarderHostname: String!

  "The port of the forwarder instance."
  forwarderPort: Int!

  "Indicates if TLS is used when the device connects to the forwarder."
  secure: Boolean!
}

"The details of a forwarder instance."
type ForwarderConfig {
  "A unique identifier"
  id: ID!

  "The hostname of the forwarder instance."
  hostname: String!

  "The port of the forwarder instance."
  port: Int!

  "Indicates if TLS should used when connecting to the forwarder."
  secureSessions: Boolean!
}

"The result of the :delete_device_group mutation"
type DeleteDeviceGroupResult {
  "The record that was successfully deleted"
  result: DeviceGroup

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_device_group mutation"
type UpdateDeviceGroupResult {
  "The successful result of the mutation"
  result: DeviceGroup

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateDeviceGroupInput {
  "The display name of the device group."
  name: String

  """
  The identifier of the device group.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  """
  The Selector that will determine which devices belong to the device group.

  This must be a valid selector expression, consult the Selector section of the Edgehog documentation for more information about Selectors.
  """
  selector: String
}

"The result of the :create_device_group mutation"
type CreateDeviceGroupResult {
  "The successful result of the mutation"
  result: DeviceGroup

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateDeviceGroupInput {
  "The display name of the device group."
  name: String!

  """
  The identifier of the device group.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  """
  The Selector that will determine which devices belong to the device group.

  This must be a valid selector expression, consult the Selector section of the Edgehog documentation for more information about Selectors.
  """
  selector: String!
}

enum DeviceGroupSortField {
  ID
  NAME
  HANDLE
  SELECTOR
}

":device_group connection"
type DeviceGroupConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":device_group edges"
  edges: [DeviceGroupEdge!]
}

":device_group edge"
type DeviceGroupEdge {
  "Cursor"
  cursor: String!

  ":device_group node"
  node: DeviceGroup!
}

input DeviceGroupFilterSelector {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceGroupFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceGroupFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceGroupFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input DeviceGroupFilterInput {
  and: [DeviceGroupFilterInput!]

  or: [DeviceGroupFilterInput!]

  not: [DeviceGroupFilterInput!]

  id: DeviceGroupFilterId

  "The display name of the device group."
  name: DeviceGroupFilterName

  """
  The identifier of the device group.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: DeviceGroupFilterHandle

  """
  The Selector that will determine which devices belong to the device group.

  This must be a valid selector expression, consult the Selector section of the Edgehog documentation for more information about Selectors.
  """
  selector: DeviceGroupFilterSelector

  "The devices belonging to the group."
  devices: DeviceFilterInput

  "The update channel associated with the group, if present."
  updateChannel: UpdateChannelFilterInput
}

input DeviceGroupSortInput {
  order: SortOrder
  field: DeviceGroupSortField!
}

type DeviceGroup implements Node {
  id: ID!

  "The display name of the device group."
  name: String!

  """
  The identifier of the device group.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  """
  The Selector that will determine which devices belong to the device group.

  This must be a valid selector expression, consult the Selector section of the Edgehog documentation for more information about Selectors.
  """
  selector: String!

  "The devices belonging to the group."
  devices(
    "How to sort the records in the response"
    sort: [DeviceSortInput]

    "A filter to limit the results"
    filter: DeviceFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [Device!]!

  "The update channel associated with the group, if present."
  updateChannel: UpdateChannel
}

enum TagSortField {
  ID
  NAME
}

":tag connection"
type TagConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":tag edges"
  edges: [TagEdge!]
}

":tag edge"
type TagEdge {
  "Cursor"
  cursor: String!

  ":tag node"
  node: Tag!
}

input TagFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input TagFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input TagFilterInput {
  and: [TagFilterInput!]
  or: [TagFilterInput!]
  not: [TagFilterInput!]
  id: TagFilterId
  name: TagFilterName
}

input TagSortInput {
  order: SortOrder
  field: TagSortField!
}

"A Tag that can be applied to a resource."
type Tag {
  id: ID!
  name: String!
}

"The result of the :create_manual_ota_operation mutation"
type CreateManualOtaOperationResult {
  "The successful result of the mutation"
  result: OtaOperation

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateManualOtaOperationInput {
  "The ID identifying the Device the OTA Operation will be sent to"
  deviceId: ID!

  "The base image file, which will be uploaded to the storage."
  baseImageFile: Upload!
}

enum OtaOperationSortField {
  ID
  BASE_IMAGE_URL
  STATUS
  STATUS_PROGRESS
  STATUS_CODE
  MESSAGE
  CREATED_AT
  UPDATED_AT
}

":ota_operation connection"
type OtaOperationConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":ota_operation edges"
  edges: [OtaOperationEdge!]
}

":ota_operation edge"
type OtaOperationEdge {
  "Cursor"
  cursor: String!

  ":ota_operation node"
  node: OtaOperation!
}

input OtaOperationFilterUpdatedAt {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime!]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input OtaOperationFilterCreatedAt {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime!]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input OtaOperationFilterMessage {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input OtaOperationFilterStatusCode {
  isNil: Boolean
  eq: OtaOperationStatusCode
  notEq: OtaOperationStatusCode
  in: [OtaOperationStatusCode]
  lessThan: OtaOperationStatusCode
  greaterThan: OtaOperationStatusCode
  lessThanOrEqual: OtaOperationStatusCode
  greaterThanOrEqual: OtaOperationStatusCode
}

input OtaOperationFilterStatusProgress {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input OtaOperationFilterStatus {
  isNil: Boolean
  eq: OtaOperationStatus
  notEq: OtaOperationStatus
  in: [OtaOperationStatus!]
  lessThan: OtaOperationStatus
  greaterThan: OtaOperationStatus
  lessThanOrEqual: OtaOperationStatus
  greaterThanOrEqual: OtaOperationStatus
}

input OtaOperationFilterBaseImageUrl {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input OtaOperationFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input OtaOperationFilterInput {
  and: [OtaOperationFilterInput!]

  or: [OtaOperationFilterInput!]

  not: [OtaOperationFilterInput!]

  id: OtaOperationFilterId

  "The URL of the base image being installed on the device"
  baseImageUrl: OtaOperationFilterBaseImageUrl

  "The current status of the operation"
  status: OtaOperationFilterStatus

  "The percentage progress [0-100] for the current status"
  statusProgress: OtaOperationFilterStatusProgress

  "The current status code of the operation"
  statusCode: OtaOperationFilterStatusCode

  "A message with additional details about the current status"
  message: OtaOperationFilterMessage

  "The creation timestamp of the operation"
  createdAt: OtaOperationFilterCreatedAt

  "The timestamp of the last update to the operation"
  updatedAt: OtaOperationFilterUpdatedAt

  "The device targeted from the operation"
  device: DeviceFilterInput

  """
  The update target of an update campaing that created the managed
  ota operation, if any.
  """
  updateTarget: UpdateTargetFilterInput
}

input OtaOperationSortInput {
  order: SortOrder
  field: OtaOperationSortField!
}

"An OTA update operation"
type OtaOperation {
  id: ID!

  "The URL of the base image being installed on the device"
  baseImageUrl: String!

  "The current status of the operation"
  status: OtaOperationStatus!

  "The percentage progress [0-100] for the current status"
  statusProgress: Int!

  "The current status code of the operation"
  statusCode: OtaOperationStatusCode

  "A message with additional details about the current status"
  message: String

  "The creation timestamp of the operation"
  createdAt: DateTime!

  "The timestamp of the last update to the operation"
  updatedAt: DateTime!

  "The device targeted from the operation"
  device: Device!

  """
  The update target of an update campaing that created the managed
  ota operation, if any.
  """
  updateTarget: UpdateTarget
}

type TenantInfo {
  id: ID!

  "The tenant name."
  name: String!

  "The tenant slug."
  slug: String!

  "The default locale supported by the tenant."
  defaultLocale: String!
}

enum UpdateTargetSortField {
  ID
  STATUS
  RETRY_COUNT
  LATEST_ATTEMPT
  COMPLETION_TIMESTAMP
}

":update_target connection"
type UpdateTargetConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":update_target edges"
  edges: [UpdateTargetEdge!]
}

":update_target edge"
type UpdateTargetEdge {
  "Cursor"
  cursor: String!

  ":update_target node"
  node: UpdateTarget!
}

input UpdateTargetFilterCompletionTimestamp {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input UpdateTargetFilterLatestAttempt {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input UpdateTargetFilterRetryCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateTargetFilterStatus {
  isNil: Boolean
  eq: UpdateTargetStatus
  notEq: UpdateTargetStatus
  in: [UpdateTargetStatus!]
  lessThan: UpdateTargetStatus
  greaterThan: UpdateTargetStatus
  lessThanOrEqual: UpdateTargetStatus
  greaterThanOrEqual: UpdateTargetStatus
}

input UpdateTargetFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateTargetFilterInput {
  and: [UpdateTargetFilterInput!]

  or: [UpdateTargetFilterInput!]

  not: [UpdateTargetFilterInput!]

  id: UpdateTargetFilterId

  "The status of the update target."
  status: UpdateTargetFilterStatus

  "The retry count of the update target. This indicates how many times Edgehog has tried to send an OTA update towards the device without receiving an ack."
  retryCount: UpdateTargetFilterRetryCount

  "The timestamp of the latest attempt to update the update target."
  latestAttempt: UpdateTargetFilterLatestAttempt

  "The timestamp when the update target completed its update, either with a success or a failure."
  completionTimestamp: UpdateTargetFilterCompletionTimestamp

  "The update campaign that is targeting the update target."
  updateCampaign: UpdateCampaignFilterInput

  "The target device."
  device: DeviceFilterInput

  "The OTA operation that tracks the update target in-progress update."
  otaOperation: OtaOperationFilterInput
}

input UpdateTargetSortInput {
  order: SortOrder
  field: UpdateTargetSortField!
}

"""
Represents an UpdateTarget.

An Update Target is the target of an Update Campaign, which is composed by the targeted device and the status of the target in the linked Update Campaign.
"""
type UpdateTarget {
  id: ID!

  "The status of the update target."
  status: UpdateTargetStatus!

  "The retry count of the update target. This indicates how many times Edgehog has tried to send an OTA update towards the device without receiving an ack."
  retryCount: Int!

  "The timestamp of the latest attempt to update the update target."
  latestAttempt: DateTime

  "The timestamp when the update target completed its update, either with a success or a failure."
  completionTimestamp: DateTime

  "The update campaign that is targeting the update target."
  updateCampaign: UpdateCampaign!

  "The target device."
  device: Device!

  "The OTA operation that tracks the update target in-progress update."
  otaOperation: OtaOperation
}

"The result of the :delete_update_channel mutation"
type DeleteUpdateChannelResult {
  "The record that was successfully deleted"
  result: UpdateChannel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_update_channel mutation"
type UpdateUpdateChannelResult {
  "The successful result of the mutation"
  result: UpdateChannel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateUpdateChannelInput {
  """
  The identifier of the update channel.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  "The display name of the update channel."
  name: String

  "The IDs of the target groups that are targeted by this update channel."
  targetGroupIds: [ID!]
}

"The result of the :create_update_channel mutation"
type CreateUpdateChannelResult {
  "The successful result of the mutation"
  result: UpdateChannel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateUpdateChannelInput {
  """
  The identifier of the update channel.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the update channel."
  name: String!

  "The IDs of the target groups that are targeted by this update channel."
  targetGroupIds: [ID!]
}

enum UpdateChannelSortField {
  ID
  HANDLE
  NAME
}

":update_channel connection"
type UpdateChannelConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":update_channel edges"
  edges: [UpdateChannelEdge!]
}

":update_channel edge"
type UpdateChannelEdge {
  "Cursor"
  cursor: String!

  ":update_channel node"
  node: UpdateChannel!
}

input UpdateChannelFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input UpdateChannelFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input UpdateChannelFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateChannelFilterInput {
  and: [UpdateChannelFilterInput!]

  or: [UpdateChannelFilterInput!]

  not: [UpdateChannelFilterInput!]

  id: UpdateChannelFilterId

  """
  The identifier of the update channel.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: UpdateChannelFilterHandle

  "The display name of the update channel."
  name: UpdateChannelFilterName

  "The device groups targeted by the update channel."
  targetGroups: DeviceGroupFilterInput
}

input UpdateChannelSortInput {
  order: SortOrder
  field: UpdateChannelSortField!
}

"""
Represents an UpdateChannel.

An UpdateChannel represents a set of device groups that can be targeted in an UpdateCampaign.
"""
type UpdateChannel implements Node {
  id: ID!

  """
  The identifier of the update channel.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the update channel."
  name: String!

  "The device groups targeted by the update channel."
  targetGroups(
    "How to sort the records in the response"
    sort: [DeviceGroupSortInput]

    "A filter to limit the results"
    filter: DeviceGroupFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): DeviceGroupConnection!
}

"The result of the :create_update_campaign mutation"
type CreateUpdateCampaignResult {
  "The successful result of the mutation"
  result: UpdateCampaign

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateUpdateCampaignInput {
  "The name of the update campaign."
  name: String!

  "The rollout mechanism used in the update campaign."
  rolloutMechanism: RolloutMechanismInput!

  "The ID of the base image that will be distributed in the update campaign."
  baseImageId: ID!

  "The ID of the update channel that will be targeted by the update campaign."
  updateChannelId: ID!
}

enum UpdateCampaignSortField {
  ID
  NAME
  STATUS
  OUTCOME
  TOTAL_TARGET_COUNT
  IDLE_TARGET_COUNT
  IN_PROGRESS_TARGET_COUNT
  FAILED_TARGET_COUNT
  SUCCESSFUL_TARGET_COUNT
}

":update_campaign connection"
type UpdateCampaignConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":update_campaign edges"
  edges: [UpdateCampaignEdge!]
}

":update_campaign edge"
type UpdateCampaignEdge {
  "Cursor"
  cursor: String!

  ":update_campaign node"
  node: UpdateCampaign!
}

input UpdateCampaignFilterSuccessfulTargetCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterFailedTargetCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterInProgressTargetCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterIdleTargetCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterTotalTargetCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterOutcome {
  isNil: Boolean
  eq: UpdateCampaignOutcome
  notEq: UpdateCampaignOutcome
  in: [UpdateCampaignOutcome]
  lessThan: UpdateCampaignOutcome
  greaterThan: UpdateCampaignOutcome
  lessThanOrEqual: UpdateCampaignOutcome
  greaterThanOrEqual: UpdateCampaignOutcome
}

input UpdateCampaignFilterStatus {
  isNil: Boolean
  eq: UpdateCampaignStatus
  notEq: UpdateCampaignStatus
  in: [UpdateCampaignStatus!]
  lessThan: UpdateCampaignStatus
  greaterThan: UpdateCampaignStatus
  lessThanOrEqual: UpdateCampaignStatus
  greaterThanOrEqual: UpdateCampaignStatus
}

input UpdateCampaignFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input UpdateCampaignFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterInput {
  and: [UpdateCampaignFilterInput!]

  or: [UpdateCampaignFilterInput!]

  not: [UpdateCampaignFilterInput!]

  id: UpdateCampaignFilterId

  "The name of the update campaign."
  name: UpdateCampaignFilterName

  "The status of the update campaign."
  status: UpdateCampaignFilterStatus

  "The outcome of the update campaign, present only when it's finished."
  outcome: UpdateCampaignFilterOutcome

  "The base image distributed by the update campaign."
  baseImage: BaseImageFilterInput

  "The update channel targeted by the update campaign."
  updateChannel: UpdateChannelFilterInput

  "The update targets belonging to the update campaign."
  updateTargets: UpdateTargetFilterInput

  "The total number of update targets."
  totalTargetCount: UpdateCampaignFilterTotalTargetCount

  "The number of update targets with an idle status."
  idleTargetCount: UpdateCampaignFilterIdleTargetCount

  "The number of update targets with an in-progress status."
  inProgressTargetCount: UpdateCampaignFilterInProgressTargetCount

  "The number of update targets with a failed status."
  failedTargetCount: UpdateCampaignFilterFailedTargetCount

  "The number of update targets with a successful status."
  successfulTargetCount: UpdateCampaignFilterSuccessfulTargetCount
}

input UpdateCampaignSortInput {
  order: SortOrder
  field: UpdateCampaignSortField!
}

"""
Represents an UpdateCampaign.

An Update Campaign is the operation that tracks the distribution of a specific Base Image to all devices belonging to an Update Channel.
"""
type UpdateCampaign implements Node {
  id: ID!

  "The name of the update campaign."
  name: String!

  "The status of the update campaign."
  status: UpdateCampaignStatus!

  "The outcome of the update campaign, present only when it's finished."
  outcome: UpdateCampaignOutcome

  "The rollout mechanism used in the update campaign."
  rolloutMechanism: RolloutMechanism!

  "The base image distributed by the update campaign."
  baseImage: BaseImage!

  "The update channel targeted by the update campaign."
  updateChannel: UpdateChannel!

  "The update targets belonging to the update campaign."
  updateTargets(
    "How to sort the records in the response"
    sort: [UpdateTargetSortInput]

    "A filter to limit the results"
    filter: UpdateTargetFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): UpdateTargetConnection!

  "The total number of update targets."
  totalTargetCount: Int!

  "The number of update targets with an idle status."
  idleTargetCount: Int!

  "The number of update targets with an in-progress status."
  inProgressTargetCount: Int!

  "The number of update targets with a failed status."
  failedTargetCount: Int!

  "The number of update targets with a successful status."
  successfulTargetCount: Int!
}

type RootQueryType {
  "Returns a single update campaign."
  updateCampaign("The id of the record" id: ID!): UpdateCampaign

  "Returns a list of update campaigns."
  updateCampaigns(
    "How to sort the records in the response"
    sort: [UpdateCampaignSortInput]

    "A filter to limit the results"
    filter: UpdateCampaignFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): UpdateCampaignConnection

  "Returns a single update channel."
  updateChannel("The id of the record" id: ID!): UpdateChannel

  "Returns a list of update channels."
  updateChannels(
    "How to sort the records in the response"
    sort: [UpdateChannelSortInput]

    "A filter to limit the results"
    filter: UpdateChannelFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): UpdateChannelConnection

  "Retrieves the current tenant."
  tenantInfo: TenantInfo!

  "Returns the list of device tags associated to some device group."
  existingDeviceTags(
    "How to sort the records in the response"
    sort: [TagSortInput]

    "A filter to limit the results"
    filter: TagFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): TagConnection

  "Returns a single device group."
  deviceGroup("The id of the record" id: ID!): DeviceGroup

  "Returns a list of device groups."
  deviceGroups(
    "How to sort the records in the response"
    sort: [DeviceGroupSortInput]

    "A filter to limit the results"
    filter: DeviceGroupFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): DeviceGroupConnection

  """
  Fetches the forwarder config, if available.
  Without a configuration, forwarding functionalities are not available.
  """
  forwarderConfig: ForwarderConfig

  "Fetches a forwarder session by its token and the device ID."
  forwarderSession(token: String!, deviceId: ID!): ForwarderSession

  "Returns a single device."
  device("The id of the record" id: ID!): Device

  "Returns a list of devices."
  devices(
    "How to sort the records in the response"
    sort: [DeviceSortInput]

    "A filter to limit the results"
    filter: DeviceFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): DeviceConnection

  "Returns a single hardware type."
  hardwareType("The id of the record" id: ID!): HardwareType

  "Returns a list of hardware types."
  hardwareTypes(
    "How to sort the records in the response"
    sort: [HardwareTypeSortInput]

    "A filter to limit the results"
    filter: HardwareTypeFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): HardwareTypeConnection

  "Returns a single system model."
  systemModel("The id of the record" id: ID!): SystemModel

  "Returns a list of system models."
  systemModels(
    "How to sort the records in the response"
    sort: [SystemModelSortInput]

    "A filter to limit the results"
    filter: SystemModelFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): SystemModelConnection

  "Retrieves a Node from its global id"
  node("The Node unique identifier" id: ID!): Node!

  "Returns a single base image."
  baseImage("The id of the record" id: ID!): BaseImage

  "Returns a single base image collection."
  baseImageCollection("The id of the record" id: ID!): BaseImageCollection

  "Returns a list of base image collections."
  baseImageCollections(
    "How to sort the records in the response"
    sort: [BaseImageCollectionSortInput]

    "A filter to limit the results"
    filter: BaseImageCollectionFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): BaseImageCollectionConnection
}

type RootMutationType {
  "Creates a new update campaign."
  createUpdateCampaign(
    input: CreateUpdateCampaignInput!
  ): CreateUpdateCampaignResult

  "Creates a new update channel."
  createUpdateChannel(
    input: CreateUpdateChannelInput!
  ): CreateUpdateChannelResult

  "Updates an update channel."
  updateUpdateChannel(
    id: ID!
    input: UpdateUpdateChannelInput
  ): UpdateUpdateChannelResult

  "Deletes an update channel."
  deleteUpdateChannel(id: ID!): DeleteUpdateChannelResult

  "Initiates an OTA update with a user provided OS image"
  createManualOtaOperation(
    input: CreateManualOtaOperationInput!
  ): CreateManualOtaOperationResult

  "Creates a new device group."
  createDeviceGroup(input: CreateDeviceGroupInput!): CreateDeviceGroupResult

  "Updates a device group."
  updateDeviceGroup(
    id: ID!
    input: UpdateDeviceGroupInput
  ): UpdateDeviceGroupResult

  "Deletes a device group."
  deleteDeviceGroup(id: ID!): DeleteDeviceGroupResult

  """
  Requests a forwarder session for the specified device.
  Returns the session token.
  """
  requestForwarderSession(input: RequestForwarderSessionInput): String!

  "Updates a device."
  updateDevice(id: ID!, input: UpdateDeviceInput): UpdateDeviceResult

  "Add tags to a device."
  addDeviceTags(id: ID!, input: AddDeviceTagsInput!): AddDeviceTagsResult

  "Remove tags from a device."
  removeDeviceTags(
    id: ID!
    input: RemoveDeviceTagsInput!
  ): RemoveDeviceTagsResult

  "Sets led behavior."
  setDeviceLedBehavior(
    id: ID!
    input: SetDeviceLedBehaviorInput!
  ): SetDeviceLedBehaviorResult

  "Creates a hardware type."
  createHardwareType(input: CreateHardwareTypeInput!): CreateHardwareTypeResult

  "Updates a hardware type."
  updateHardwareType(
    id: ID!
    input: UpdateHardwareTypeInput
  ): UpdateHardwareTypeResult

  "Deletes a hardware type."
  deleteHardwareType(id: ID!): DeleteHardwareTypeResult

  "Creates a system model."
  createSystemModel(input: CreateSystemModelInput!): CreateSystemModelResult

  "Updates an system model."
  updateSystemModel(
    id: ID!
    input: UpdateSystemModelInput
  ): UpdateSystemModelResult

  "Deletes a system model."
  deleteSystemModel(id: ID!): DeleteSystemModelResult

  "Create a new base image in a base image collection."
  createBaseImage(input: CreateBaseImageInput!): CreateBaseImageResult

  "Updates a base image."
  updateBaseImage(id: ID!, input: UpdateBaseImageInput): UpdateBaseImageResult

  "Deletes a base image."
  deleteBaseImage(id: ID!): DeleteBaseImageResult

  "Creates a new base image collection."
  createBaseImageCollection(
    input: CreateBaseImageCollectionInput!
  ): CreateBaseImageCollectionResult

  "Updates a base image collection."
  updateBaseImageCollection(
    id: ID!
    input: UpdateBaseImageCollectionInput
  ): UpdateBaseImageCollectionResult

  "Deletes a base image collection."
  deleteBaseImageCollection(id: ID!): DeleteBaseImageCollectionResult
}

"""
The `Json` scalar type represents arbitrary json string data, represented as UTF-8
character sequences. The Json type is most often used to represent a free-form
human-readable json string.
"""
scalar Json

"""
The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime

"Represents an uploaded file."
scalar Upload

"""
Describes hardware-related info of a device.

It exposes data read by a device's operating system about the underlying hardware.
"""
type HardwareInfo {
  "The architecture of the CPU."
  cpuArchitecture: String

  "The reference code of the CPU model."
  cpuModel: String

  "The display name of the CPU model."
  cpuModelName: String

  "The vendor's name."
  cpuVendor: String

  "The Bytes count of memory."
  memoryTotalBytes: Int
}

"Describes the current usage of a storage unit on a device."
type StorageUnit {
  "The label of the storage unit."
  label: String!

  "The total number of bytes of the storage unit."
  totalBytes: Int

  "The number of free bytes of the storage unit."
  freeBytes: Int
}

"Describes the information on the system's base image for a device."
type BaseImageInfo {
  "The name of the image."
  name: String

  "The version of the image."
  version: String

  "Human readable build identifier of the image."
  buildId: String

  "A unique string that identifies the release, usually the image hash."
  fingerprint: String
}

"Describes an operating system of a device."
type OsInfo {
  "The name of the operating system."
  name: String

  "The version of the operating system."
  version: String
}

"Describes the current status of the operating system of a device."
type SystemStatus {
  "The identifier of the performed boot sequence."
  bootId: String

  "The number of free bytes of memory."
  memoryFreeBytes: Int

  "The number of running tasks on the system."
  taskCount: Int

  "The number of milliseconds since the last system boot."
  uptimeMilliseconds: Int

  "The date at which the system status was read."
  timestamp: DateTime!
}

"Describes the list of WiFi Access Points found by the device."
type WifiScanResult {
  "The channel used by the Access Point."
  channel: Int

  "Indicates whether the device is connected to the Access Point."
  connected: Boolean

  "The ESSID advertised by the Access Point."
  essid: String

  "The MAC address advertised by the Access Point."
  macAddress: String

  "The power of the radio signal, measured in dBm."
  rssi: Int

  "The date at which the device found the Access Point."
  timestamp: DateTime!
}

"Describes an Edgehog runtime."
type RuntimeInfo {
  "The name of the Edgehog runtime."
  name: String

  "The version of the Edgehog runtime."
  version: String

  "The environment of the Edgehog runtime."
  environment: String

  "The URL that uniquely identifies the Edgehog runtime implementation."
  url: String
}
