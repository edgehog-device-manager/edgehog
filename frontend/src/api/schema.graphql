schema {
  mutation: RootMutationType
  query: RootQueryType
}

input UpdateCampaignRolloutMechanismPushInput {
  "This boolean flag determines if the Base Image will be pushed to the Device even if it already has a greater version of the Base Image."
  forceDowngrade: Boolean

  "The maximum percentage of failures allowed over the number of total targets. If the failures exceed this threshold, the Update Campaign terminates with a failure."
  maxFailurePercentage: Float

  "The maximum number of in progress updates. The Update Campaign will have at most this number of OTA Operations that are started but not yet finished (either successfully or not)."
  maxInProgressUpdates: Int

  "The number of attempts that have to be tried before giving up on the update of a specific target (and considering it an error). Note that the update is retried only if the OTA Request doesn't get acknowledged from the device."
  otaRequestRetries: Int

  "The timeout (in seconds) Edgehog has to wait before considering an OTA Request lost (and possibly retry). It must be at least 30 seconds."
  otaRequestTimeoutSeconds: Int
}

"An object representing the properties of a Push Rollout Mechanism."
type PushRollout {
  "This boolean flag determines if the Base Image will be pushed to the Device even if it already has a greater version of the Base Image."
  forceDowngrade: Boolean!

  "The maximum percentage of failures allowed over the number of total targets. If the failures exceed this threshold, the Update Campaign terminates with a failure."
  maxFailurePercentage: Float!

  "The maximum number of in progress updates. The Update Campaign will have at most this number of OTA Operations that are started but not yet finished (either successfully or not)."
  maxInProgressUpdates: Int!

  "The number of attempts that have to be tried before giving up on the update of a specific target (and considering it an error). Note that the update is retried only if the OTA Request doesn't get acknowledged from the device."
  otaRequestRetries: Int!

  "The timeout (in seconds) Edgehog has to wait before considering an OTA Request lost (and possibly retry). It must be at least 30 seconds."
  otaRequestTimeoutSeconds: Int!
}

"Describes a modem of a device."
type Modem {
  "The operator apn address."
  apn: String

  "Carrier operator name."
  carrier: String

  "Unique identifier of the cell."
  cellId: Int

  "The modem IMEI code."
  imei: String

  "The SIM IMSI code."
  imsi: String

  "The Local Area Code."
  localAreaCode: Int

  "The cell tower's Mobile Country Code (MCC)."
  mobileCountryCode: Int

  "The cell tower's Mobile Network Code."
  mobileNetworkCode: Int

  "The GSM/LTE registration status of the modem."
  registrationStatus: ModemRegistrationStatus

  "Signal strength in dBm."
  rssi: Float

  "The identifier of the modem."
  slot: String!

  "The access technology of the serving cell."
  technology: ModemTechnology
}

"Describes a battery slot of a device."
type BatterySlot {
  "Battery level measurement absolute error [0.0-100.0]."
  levelAbsoluteError: Float

  "Battery level estimated percentage [0.0%-100.0%]."
  levelPercentage: Float

  "The identifier of the battery slot."
  slot: String!

  "The current status of the battery."
  status: BatterySlotStatus
}

"""
Describes the place where a device is located.

The field holds information about the device's address, which is
estimated by means of Edgehog's geolocation modules and the data
published by the device.
"""
type Location {
  "The formatted address associated with the location."
  formattedAddress: String!

  "The date and time at which the location was measured."
  timestamp: DateTime!

  "Describes how the location was calculated."
  source: String
}

"Describes a network interface of a device."
type NetworkInterface {
  "The identifier of the network interface."
  name: String!

  "The normalized physical address."
  macAddress: String

  "The connection technology."
  technology: NetworkInterfaceTechnology
}

"""
Describes the position of a device.

The field holds information about the GPS coordinates of the device,
which are estimated by means of Edgehog's geolocation modules and the
data published by the device.
"""
type Position {
  "The latitude coordinate."
  latitude: Float!

  "The longitude coordinate."
  longitude: Float!

  "The accuracy of the measurement, in meters."
  accuracy: Float

  "The altitude coordinate."
  altitude: Float

  "The accuracy of the altitude measurement, in meters."
  altitudeAccuracy: Float

  "The measured heading."
  heading: Float

  "The measured speed."
  speed: Float

  "The date and time at which the measurement was made."
  timestamp: DateTime!

  "Describes how the position was calculated."
  source: String
}

input RolloutMechanismInput {
  push: UpdateCampaignRolloutMechanismPushInput
}

union RolloutMechanism = PushRollout

enum UpdateTargetStatus {
  "The update campaign is waiting for the OTA Request to be sent."
  IDLE

  "The update target is in progress."
  IN_PROGRESS

  "The update target has failed to be updated."
  FAILED

  "The update target was successfully updated."
  SUCCESSFUL
}

enum UpdateCampaignStatus {
  "The update campaign has been created but is not being rolled-out yet."
  IDLE

  "The update campaign is being rolled-out."
  IN_PROGRESS

  "The update campaign has finished."
  FINISHED
}

enum UpdateCampaignOutcome {
  "The update campaign has finished succesfully."
  SUCCESS

  "The update campaign has finished with a failure."
  FAILURE
}

enum OtaOperationStatus {
  "The OTA operation was created and is waiting an acknowledgment from the device"
  PENDING

  "The OTA operation was acknowledged from the device"
  ACKNOWLEDGED

  "The device is downloading the update"
  DOWNLOADING

  "The device is deploying the update"
  DEPLOYING

  "The device deployed the update"
  DEPLOYED

  "The device is in the process of rebooting"
  REBOOTING

  "A recoverable error happened during the OTA operation"
  ERROR

  "The OTA operation ended with a failure. This is a final state of the OTA Operation"
  FAILURE

  "The OTA operation ended successfully. This is a final state of the OTA Operation"
  SUCCESS
}

enum OtaOperationStatusCode {
  "The OTA Operation timed out while sending the request to the device"
  REQUEST_TIMEOUT

  "The OTA Operation contained invalid data"
  INVALID_REQUEST

  "An OTA Operation is already in progress on the device"
  UPDATE_ALREADY_IN_PROGRESS

  "A network error was encountered"
  NETWORK_ERROR

  "An IO error was encountered"
  IO_ERROR

  "An internal error was encountered"
  INTERNAL_ERROR

  "The OTA Operation failed due to an invalid base image"
  INVALID_BASE_IMAGE

  "A system rollback has occurred"
  SYSTEM_ROLLBACK

  "The OTA Operation was canceled"
  CANCELED
}

enum ForwarderSessionStatus {
  "The device is connected to the forwarder."
  CONNECTED

  "The device is connecting to the forwarder."
  CONNECTING
}

enum DeviceLedBehavior {
  "Blink for 60 seconds."
  BLINK

  "Double blink for 60 seconds."
  DOUBLE_BLINK

  "Slow blink for 60 seconds."
  SLOW_BLINK
}

enum DeviceCapability {
  "The device provides information about its base image."
  BASE_IMAGE

  "The device provides information about its battery status."
  BATTERY_STATUS

  "The device provides information about its cellular connection."
  CELLULAR_CONNECTION

  "The device supports commands, for example the rebooting command."
  COMMANDS

  "The device supports running applications using containers."
  CONTAINER_MANAGEMENT

  "The device can be geolocated."
  GEOLOCATION

  "The device provides information about its hardware."
  HARDWARE_INFO

  "The device can be asked to blink its LED in a specific pattern."
  LED_BEHAVIORS

  "The device can provide information about its network interfaces."
  NETWORK_INTERFACE_INFO

  "The device provides information about its operating system."
  OPERATING_SYSTEM

  "The device supports remote terminal sessions."
  REMOTE_TERMINAL

  "The device provides information about its runtime."
  RUNTIME_INFO

  "The device can be updated remotely."
  SOFTWARE_UPDATES

  "The device provides information about its storage units."
  STORAGE

  "The device provides information about its system."
  SYSTEM_INFO

  "The device provides information about its system status."
  SYSTEM_STATUS

  "The device telemetry can be configured."
  TELEMETRY_CONFIG

  "The device provides information about surrounding WiFi APs."
  WIFI
}

enum ModemRegistrationStatus {
  "Not registered, modem is not currently searching a new operator to register to."
  NOT_REGISTERED

  "Registered, home network."
  REGISTERED

  "Not registered, but modem is currently searching a new operator to register to."
  SEARCHING_OPERATOR

  "Registration denied."
  REGISTRATION_DENIED

  "Unknown (e.g. out of GERAN/UTRAN/E-UTRAN coverage)."
  UNKNOWN

  "Registered, roaming."
  REGISTERED_ROAMING
}

enum ModemTechnology {
  "GSM."
  GSM

  "GSM Compact."
  GSM_COMPACT

  "UTRAN."
  UTRAN

  "GSM with EGPRS."
  GSM_EGPRS

  "UTRAN with HSDPA."
  UTRAN_HSDPA

  "UTRAN with HSUPA."
  UTRAN_HSUPA

  "UTRAN with HSDPA and HSUPA."
  UTRAN_HSDPA_HSUPA

  "E-UTRAN."
  EUTRAN
}

enum BatterySlotStatus {
  "The battery is charging."
  CHARGING

  "The battery is discharging."
  DISCHARGING

  "The battery is idle."
  IDLE

  "The battery is either in a charging or in an idle state, since the hardware doesn't allow to distinguish between them."
  EITHER_IDLE_OR_CHARGING

  "The battery is in a failed state."
  FAILURE

  "The battery is removed."
  REMOVED

  "The battery status cannot be determined."
  UNKNOWN
}

enum NetworkInterfaceTechnology {
  "Ethernet."
  ETHERNET

  "Bluetooth."
  BLUETOOTH

  "Cellular."
  CELLULAR

  "WiFi."
  WIFI
}

enum ApplicationDeploymentStatus {
  "The deployment process entered an error state."
  ERROR

  "The deployment is running."
  STARTED

  "The deployment is starting."
  STARTING

  "The deployment has stopped."
  STOPPED

  "The deploymen is stopping."
  STOPPING
}

input LocalizedAttributeUpdateInput {
  value: String
  languageTag: String!
}

input LocalizedAttributeInput {
  value: String!
  languageTag: String!
}

type LocalizedAttribute {
  value: String!
  languageTag: String!
}

"The result of the :delete_base_image_collection mutation"
type DeleteBaseImageCollectionResult {
  "The record that was successfully deleted"
  result: BaseImageCollection

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_base_image_collection mutation"
type UpdateBaseImageCollectionResult {
  "The successful result of the mutation"
  result: BaseImageCollection

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateBaseImageCollectionInput {
  "The display name of the base image collection."
  name: String

  """
  The identifier of the base image collection.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String
}

"The result of the :create_base_image_collection mutation"
type CreateBaseImageCollectionResult {
  "The successful result of the mutation"
  result: BaseImageCollection

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateBaseImageCollectionInput {
  "The display name of the base image collection."
  name: String!

  """
  The identifier of the base image collection.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The ID of the system model that is targeted by the base image collection"
  systemModelId: ID!
}

enum BaseImageCollectionSortField {
  ID
  NAME
  HANDLE
}

input BaseImageCollectionFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input BaseImageCollectionFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input BaseImageCollectionFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input BaseImageCollectionFilterInput {
  and: [BaseImageCollectionFilterInput!]

  or: [BaseImageCollectionFilterInput!]

  not: [BaseImageCollectionFilterInput!]

  id: BaseImageCollectionFilterId

  "The display name of the base image collection."
  name: BaseImageCollectionFilterName

  """
  The identifier of the base image collection.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: BaseImageCollectionFilterHandle

  "The system model associated with the base image collection."
  systemModel: SystemModelFilterInput

  "The base images associated with the base image collection."
  baseImages: BaseImageFilterInput
}

input BaseImageCollectionSortInput {
  order: SortOrder
  field: BaseImageCollectionSortField!
}

"""
Represents a collection of Base Images.

A base image collection represents the collection of all Base Images that can run on a specific System Model.
"""
type BaseImageCollection implements Node {
  id: ID!

  "The display name of the base image collection."
  name: String!

  """
  The identifier of the base image collection.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The system model associated with the base image collection."
  systemModel: SystemModel!

  "The base images associated with the base image collection."
  baseImages(
    "How to sort the records in the response"
    sort: [BaseImageSortInput]

    "A filter to limit the results"
    filter: BaseImageFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [BaseImage!]!
}

"The result of the :delete_base_image mutation"
type DeleteBaseImageResult {
  "The record that was successfully deleted"
  result: BaseImage

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_base_image mutation"
type UpdateBaseImageResult {
  "The successful result of the mutation"
  result: BaseImage

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateBaseImageInput {
  "The starting version requirement for the base image."
  startingVersionRequirement: String

  "A list of descriptions in different languages."
  localizedDescriptions: [LocalizedAttributeUpdateInput!]

  "A list of release display names in different languages."
  localizedReleaseDisplayNames: [LocalizedAttributeUpdateInput!]
}

"The result of the :create_base_image mutation"
type CreateBaseImageResult {
  "The successful result of the mutation"
  result: BaseImage

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateBaseImageInput {
  "The base image version."
  version: String!

  "The starting version requirement for the base image."
  startingVersionRequirement: String

  "The ID of the base image collection this base image will belong to."
  baseImageCollectionId: ID!

  "The base image file, which will be uploaded to the storage."
  file: Upload!

  "A list of descriptions in different languages."
  localizedDescriptions: [LocalizedAttributeInput!]

  "A list of release display names in different languages."
  localizedReleaseDisplayNames: [LocalizedAttributeInput!]
}

enum BaseImageSortField {
  ID
  VERSION
  STARTING_VERSION_REQUIREMENT
  URL
}

input BaseImageFilterUrl {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input BaseImageFilterStartingVersionRequirement {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input BaseImageFilterVersion {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input BaseImageFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input BaseImageFilterInput {
  and: [BaseImageFilterInput!]

  or: [BaseImageFilterInput!]

  not: [BaseImageFilterInput!]

  id: BaseImageFilterId

  "The base image version."
  version: BaseImageFilterVersion

  "The starting version requirement for the base image."
  startingVersionRequirement: BaseImageFilterStartingVersionRequirement

  "The url where the base image can be downloaded."
  url: BaseImageFilterUrl

  "The base image collection that this base image belongs to."
  baseImageCollection: BaseImageCollectionFilterInput
}

input BaseImageSortInput {
  order: SortOrder
  field: BaseImageSortField!
}

"""
Represents an uploaded Base Image.

A base image represents a downloadable base image that can be installed on a device
"""
type BaseImage implements Node {
  id: ID!

  "The base image version."
  version: String!

  "The starting version requirement for the base image."
  startingVersionRequirement: String

  "The url where the base image can be downloaded."
  url: String!

  "The base image collection that this base image belongs to."
  baseImageCollection: BaseImageCollection!

  "A list of descriptions in different languages."
  localizedDescriptions(preferredLanguageTags: [String!]): [LocalizedAttribute!]

  "A list of release display names in different languages."
  localizedReleaseDisplayNames(
    preferredLanguageTags: [String!]
  ): [LocalizedAttribute!]
}

"A relay page info"
type PageInfo {
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!

  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!

  "When paginating backwards, the cursor to continue"
  startCursor: String

  "When paginating forwards, the cursor to continue"
  endCursor: String
}

"A relay node"
interface Node {
  "A unique identifier"
  id: ID!
}

enum SortOrder {
  DESC
  DESC_NULLS_FIRST
  DESC_NULLS_LAST
  ASC
  ASC_NULLS_FIRST
  ASC_NULLS_LAST
}

"An error generated by a failed mutation"
type MutationError {
  "The human readable error message"
  message: String

  "A shorter error message, with vars not replaced"
  shortMessage: String

  "Replacements for the short message"
  vars: Json

  "An error code for the given error"
  code: String

  "The field or fields that produced the error"
  fields: [String!]
}

enum NetworkSortField {
  ID
  DRIVER
  CHECK_DUPLICATE
  INTERNAL
  ENABLE_IPV6
}

":network connection"
type NetworkConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":network edges"
  edges: [NetworkEdge!]
}

":network edge"
type NetworkEdge {
  "Cursor"
  cursor: String!

  ":network node"
  node: Network!
}

input NetworkFilterEnableIpv6 {
  isNil: Boolean
  eq: Boolean
  notEq: Boolean
  in: [Boolean!]
  lessThan: Boolean
  greaterThan: Boolean
  lessThanOrEqual: Boolean
  greaterThanOrEqual: Boolean
}

input NetworkFilterInternal {
  isNil: Boolean
  eq: Boolean
  notEq: Boolean
  in: [Boolean!]
  lessThan: Boolean
  greaterThan: Boolean
  lessThanOrEqual: Boolean
  greaterThanOrEqual: Boolean
}

input NetworkFilterCheckDuplicate {
  isNil: Boolean
  eq: Boolean
  notEq: Boolean
  in: [Boolean!]
  lessThan: Boolean
  greaterThan: Boolean
  lessThanOrEqual: Boolean
  greaterThanOrEqual: Boolean
}

input NetworkFilterDriver {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input NetworkFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input NetworkFilterInput {
  and: [NetworkFilterInput!]
  or: [NetworkFilterInput!]
  not: [NetworkFilterInput!]
  id: NetworkFilterId
  driver: NetworkFilterDriver
  checkDuplicate: NetworkFilterCheckDuplicate
  internal: NetworkFilterInternal
  enableIpv6: NetworkFilterEnableIpv6
}

input NetworkSortInput {
  order: SortOrder
  field: NetworkSortField!
}

type Network {
  id: ID!
  driver: String!
  checkDuplicate: Boolean!
  internal: Boolean!
  enableIpv6: Boolean!
}

enum ReleaseSortField {
  ID
  VERSION
  APPLICATION_ID
}

":release connection"
type ReleaseConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":release edges"
  edges: [ReleaseEdge!]
}

":release edge"
type ReleaseEdge {
  "Cursor"
  cursor: String!

  ":release node"
  node: Release!
}

input ReleaseFilterApplicationId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input ReleaseFilterVersion {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input ReleaseFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input ReleaseFilterInput {
  and: [ReleaseFilterInput!]
  or: [ReleaseFilterInput!]
  not: [ReleaseFilterInput!]
  id: ReleaseFilterId
  version: ReleaseFilterVersion
  applicationId: ReleaseFilterApplicationId
  application: ApplicationFilterInput
  containers: ContainerFilterInput
}

input ReleaseSortInput {
  order: SortOrder
  field: ReleaseSortField!
}

type Release implements Node {
  id: ID!
  version: String!
  applicationId: ID
  application: Application
  containers(
    "How to sort the records in the response"
    sort: [ContainerSortInput]

    "A filter to limit the results"
    filter: ContainerFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): ContainerConnection!
}

"The result of the :delete_image_credentials mutation"
type DeleteImageCredentialsResult {
  "The record that was successfully deleted"
  result: ImageCredentials

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :create_image_credentials mutation"
type CreateImageCredentialsResult {
  "The successful result of the mutation"
  result: ImageCredentials

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateImageCredentialsInput {
  label: String!
  username: String!
  password: String!
}

enum ImageCredentialsSortField {
  ID
  LABEL
  USERNAME
}

"A keyset page of :image_credentials"
type KeysetPageOfImageCredentials {
  "Total count on all pages"
  count: Int

  "The records contained in the page"
  results: [ImageCredentials!]

  "The first keyset in the results"
  startKeyset: String

  "The last keyset in the results"
  endKeyset: String
}

input ImageCredentialsFilterUsername {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input ImageCredentialsFilterLabel {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input ImageCredentialsFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input ImageCredentialsFilterInput {
  and: [ImageCredentialsFilterInput!]
  or: [ImageCredentialsFilterInput!]
  not: [ImageCredentialsFilterInput!]
  id: ImageCredentialsFilterId
  label: ImageCredentialsFilterLabel
  username: ImageCredentialsFilterUsername
}

input ImageCredentialsSortInput {
  order: SortOrder
  field: ImageCredentialsSortField!
}

"""
Contains the credentials used to pull an image from a device.

Credentials are uniquely identified trough their `:id`, a unique
`name` field is also provided. The module stores `username` and
`password`
"""
type ImageCredentials implements Node {
  id: ID!
  label: String!
  username: String!
}

input ImageFilterImageCredentialsId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input ImageFilterReference {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input ImageFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input ImageFilterInput {
  and: [ImageFilterInput!]
  or: [ImageFilterInput!]
  not: [ImageFilterInput!]
  id: ImageFilterId
  reference: ImageFilterReference
  imageCredentialsId: ImageFilterImageCredentialsId
  credentials: ImageCredentialsFilterInput
}

type Image {
  id: ID!
  reference: String!
  imageCredentialsId: ID
  credentials: ImageCredentials
}

"The result of the :stop_deployment mutation"
type StopDeploymentResult {
  "The successful result of the mutation"
  result: Deployment

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :start_deployment mutation"
type StartDeploymentResult {
  "The successful result of the mutation"
  result: Deployment

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :deploy_release mutation"
type DeployReleaseResult {
  "The successful result of the mutation"
  result: Deployment

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input DeployReleaseInput {
  deviceId: ID
  releaseId: ID
}

enum DeploymentSortField {
  ID
  STATUS
  DEVICE_ID
  RELEASE_ID
}

":deployment connection"
type DeploymentConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":deployment edges"
  edges: [DeploymentEdge!]
}

":deployment edge"
type DeploymentEdge {
  "Cursor"
  cursor: String!

  ":deployment node"
  node: Deployment!
}

input DeploymentFilterReleaseId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input DeploymentFilterDeviceId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input DeploymentFilterStatus {
  isNil: Boolean
  eq: ApplicationDeploymentStatus
  notEq: ApplicationDeploymentStatus
  in: [ApplicationDeploymentStatus]
  lessThan: ApplicationDeploymentStatus
  greaterThan: ApplicationDeploymentStatus
  lessThanOrEqual: ApplicationDeploymentStatus
  greaterThanOrEqual: ApplicationDeploymentStatus
}

input DeploymentFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input DeploymentFilterInput {
  and: [DeploymentFilterInput!]
  or: [DeploymentFilterInput!]
  not: [DeploymentFilterInput!]
  id: DeploymentFilterId
  status: DeploymentFilterStatus
  deviceId: DeploymentFilterDeviceId
  releaseId: DeploymentFilterReleaseId
  device: DeviceFilterInput
  release: ReleaseFilterInput
}

input DeploymentSortInput {
  order: SortOrder
  field: DeploymentSortField!
}

type Deployment {
  id: ID!
  status: ApplicationDeploymentStatus
  deviceId: Int
  releaseId: ID
  device: Device
  release: Release
}

enum ContainerSortField {
  ID
  RESTART_POLICY
  HOSTNAME
  ENV
  PRIVILEGED
  IMAGE_ID
}

":container connection"
type ContainerConnection {
  "Total count on all pages"
  count: Int

  "Page information"
  pageInfo: PageInfo!

  ":container edges"
  edges: [ContainerEdge!]
}

":container edge"
type ContainerEdge {
  "Cursor"
  cursor: String!

  ":container node"
  node: Container!
}

input ContainerFilterImageId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input ContainerFilterPrivileged {
  isNil: Boolean
  eq: Boolean
  notEq: Boolean
  in: [Boolean]
  lessThan: Boolean
  greaterThan: Boolean
  lessThanOrEqual: Boolean
  greaterThanOrEqual: Boolean
}

input ContainerFilterEnv {
  isNil: Boolean
  eq: JsonString
  notEq: JsonString
  in: [JsonString]
  lessThan: JsonString
  greaterThan: JsonString
  lessThanOrEqual: JsonString
  greaterThanOrEqual: JsonString
}

input ContainerFilterHostname {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input ContainerFilterRestartPolicy {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
}

input ContainerFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input ContainerFilterInput {
  and: [ContainerFilterInput!]
  or: [ContainerFilterInput!]
  not: [ContainerFilterInput!]
  id: ContainerFilterId
  restartPolicy: ContainerFilterRestartPolicy
  hostname: ContainerFilterHostname
  env: ContainerFilterEnv
  privileged: ContainerFilterPrivileged
  imageId: ContainerFilterImageId
  image: ImageFilterInput
  networks: NetworkFilterInput
}

input ContainerSortInput {
  order: SortOrder
  field: ContainerSortField!
}

type Container {
  id: ID!
  restartPolicy: String
  portBindings: [String!]!
  hostname: String!
  env: JsonString
  privileged: Boolean
  imageId: ID!
  image: Image!
  networks(
    "How to sort the records in the response"
    sort: [NetworkSortInput]

    "A filter to limit the results"
    filter: NetworkFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): NetworkConnection!
}

enum ApplicationSortField {
  ID
  NAME
  DESCRIPTION
}

"A keyset page of :application"
type KeysetPageOfApplication {
  "Total count on all pages"
  count: Int

  "The records contained in the page"
  results: [Application!]

  "The first keyset in the results"
  startKeyset: String

  "The last keyset in the results"
  endKeyset: String
}

input ApplicationFilterDescription {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input ApplicationFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input ApplicationFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input ApplicationFilterInput {
  and: [ApplicationFilterInput!]
  or: [ApplicationFilterInput!]
  not: [ApplicationFilterInput!]
  id: ApplicationFilterId
  name: ApplicationFilterName
  description: ApplicationFilterDescription
  releases: ReleaseFilterInput
}

input ApplicationSortInput {
  order: SortOrder
  field: ApplicationSortField!
}

type Application implements Node {
  id: ID!
  name: String!
  description: String
  releases(
    "How to sort the records in the response"
    sort: [ReleaseSortInput]

    "A filter to limit the results"
    filter: ReleaseFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): ReleaseConnection!
}

enum SystemModelPartNumberSortField {
  ID
  PART_NUMBER
}

input SystemModelPartNumberFilterPartNumber {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelPartNumberFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input SystemModelPartNumberFilterInput {
  and: [SystemModelPartNumberFilterInput!]

  or: [SystemModelPartNumberFilterInput!]

  not: [SystemModelPartNumberFilterInput!]

  id: SystemModelPartNumberFilterId

  "The part number identifier."
  partNumber: SystemModelPartNumberFilterPartNumber

  systemModel: SystemModelFilterInput
}

input SystemModelPartNumberSortInput {
  order: SortOrder
  field: SystemModelPartNumberSortField!
}

type SystemModelPartNumber {
  id: ID!

  "The part number identifier."
  partNumber: String!

  systemModel: SystemModel
}

"The result of the :delete_system_model mutation"
type DeleteSystemModelResult {
  "The record that was successfully deleted"
  result: SystemModel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_system_model mutation"
type UpdateSystemModelResult {
  "The successful result of the mutation"
  result: SystemModel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateSystemModelInput {
  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  "The display name of the system model."
  name: String

  "A URL to a picture representing the system model."
  pictureUrl: String

  "The list of part numbers associated with the system model."
  partNumbers: [String!]

  "A picture representing the system model that will be uploaded to a bucket."
  pictureFile: Upload

  """
  A list of descriptions in different languages.

  If a language already exists it is updated. If a null value is passed, the language
  is deleted.
  """
  localizedDescriptions: [LocalizedAttributeUpdateInput!]
}

"The result of the :create_system_model mutation"
type CreateSystemModelResult {
  "The successful result of the mutation"
  result: SystemModel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateSystemModelInput {
  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the system model."
  name: String!

  "A URL to a picture representing the system model."
  pictureUrl: String

  "The ID of the hardware type that can be used by devices of this model"
  hardwareTypeId: ID!

  "The list of part numbers associated with the system model."
  partNumbers: [String!]!

  "A picture representing the system model that will be uploaded to a bucket."
  pictureFile: Upload

  "A list of descriptions in different languages."
  localizedDescriptions: [LocalizedAttributeInput!]
}

enum SystemModelSortField {
  ID
  HANDLE
  NAME
  PICTURE_URL
}

input SystemModelFilterPictureUrl {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input SystemModelFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input SystemModelFilterInput {
  and: [SystemModelFilterInput!]

  or: [SystemModelFilterInput!]

  not: [SystemModelFilterInput!]

  id: SystemModelFilterId

  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: SystemModelFilterHandle

  "The display name of the system model."
  name: SystemModelFilterName

  "A URL to a picture representing the system model."
  pictureUrl: SystemModelFilterPictureUrl

  "The list of part numbers associated with the system model."
  partNumbers: SystemModelPartNumberFilterInput

  "The Hardware type associated with the System Model"
  hardwareType: HardwareTypeFilterInput
}

input SystemModelSortInput {
  order: SortOrder
  field: SystemModelSortField!
}

"""
A system model corresponds to what the users thinks as functionally
equivalent devices (e.g. two revisions of a device containing two different
embedded chips but having the same enclosure and the same functionality).
Each SystemModel must be associated to a specific HardwareType.
"""
type SystemModel implements Node {
  id: ID!

  """
  The identifier of the system model.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the system model."
  name: String!

  "A URL to a picture representing the system model."
  pictureUrl: String

  "The list of part numbers associated with the system model."
  partNumbers(
    "How to sort the records in the response"
    sort: [SystemModelPartNumberSortInput]

    "A filter to limit the results"
    filter: SystemModelPartNumberFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [SystemModelPartNumber!]!

  "The Hardware type associated with the System Model"
  hardwareType: HardwareType

  "A list of descriptions in different languages."
  localizedDescriptions(preferredLanguageTags: [String!]): [LocalizedAttribute!]
}

enum HardwareTypePartNumberSortField {
  ID
  PART_NUMBER
}

input HardwareTypePartNumberFilterPartNumber {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input HardwareTypePartNumberFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input HardwareTypePartNumberFilterInput {
  and: [HardwareTypePartNumberFilterInput!]

  or: [HardwareTypePartNumberFilterInput!]

  not: [HardwareTypePartNumberFilterInput!]

  id: HardwareTypePartNumberFilterId

  "The part number identifier."
  partNumber: HardwareTypePartNumberFilterPartNumber

  hardwareType: HardwareTypeFilterInput
}

input HardwareTypePartNumberSortInput {
  order: SortOrder
  field: HardwareTypePartNumberSortField!
}

type HardwareTypePartNumber {
  id: ID!

  "The part number identifier."
  partNumber: String!

  hardwareType: HardwareType
}

"The result of the :delete_hardware_type mutation"
type DeleteHardwareTypeResult {
  "The record that was successfully deleted"
  result: HardwareType

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_hardware_type mutation"
type UpdateHardwareTypeResult {
  "The successful result of the mutation"
  result: HardwareType

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateHardwareTypeInput {
  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  "The display name of the hardware type."
  name: String

  "The list of part numbers associated with the hardware type."
  partNumbers: [String!]
}

"The result of the :create_hardware_type mutation"
type CreateHardwareTypeResult {
  "The successful result of the mutation"
  result: HardwareType

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateHardwareTypeInput {
  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the hardware type."
  name: String!

  partNumbers: [String!]!
}

enum HardwareTypeSortField {
  ID
  HANDLE
  NAME
}

input HardwareTypeFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input HardwareTypeFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input HardwareTypeFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input HardwareTypeFilterInput {
  and: [HardwareTypeFilterInput!]

  or: [HardwareTypeFilterInput!]

  not: [HardwareTypeFilterInput!]

  id: HardwareTypeFilterId

  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: HardwareTypeFilterHandle

  "The display name of the hardware type."
  name: HardwareTypeFilterName

  "The list of part numbers associated with the hardware type."
  partNumbers: HardwareTypePartNumberFilterInput
}

input HardwareTypeSortInput {
  order: SortOrder
  field: HardwareTypeSortField!
}

"""
Denotes a type of hardware that devices can have.

It refers to the physical components embedded in a device.
This can represent, e.g., multiple revisions of a PCB (each with a
different part number) which are functionally equivalent from the device
point of view.
"""
type HardwareType implements Node {
  id: ID!

  """
  The identifier of the hardware type.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the hardware type."
  name: String!

  "The list of part numbers associated with the hardware type."
  partNumbers(
    "How to sort the records in the response"
    sort: [HardwareTypePartNumberSortInput]

    "A filter to limit the results"
    filter: HardwareTypePartNumberFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [HardwareTypePartNumber!]!
}

"The result of the :set_device_led_behavior mutation"
type SetDeviceLedBehaviorResult {
  "The successful result of the mutation"
  result: Device

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input SetDeviceLedBehaviorInput {
  "The led behavior."
  behavior: DeviceLedBehavior!
}

"The result of the :remove_device_tags mutation"
type RemoveDeviceTagsResult {
  "The successful result of the mutation"
  result: Device

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input RemoveDeviceTagsInput {
  tags: [String!]!
}

"The result of the :add_device_tags mutation"
type AddDeviceTagsResult {
  "The successful result of the mutation"
  result: Device

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input AddDeviceTagsInput {
  tags: [String!]!
}

"The result of the :update_device mutation"
type UpdateDeviceResult {
  "The successful result of the mutation"
  result: Device

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateDeviceInput {
  "The display name of the device."
  name: String
}

enum DeviceSortField {
  ID
  DEVICE_ID
  NAME
  ONLINE
  LAST_CONNECTION
  LAST_DISCONNECTION
  SERIAL_NUMBER
}

input DeviceFilterSerialNumber {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceFilterLastDisconnection {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input DeviceFilterLastConnection {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input DeviceFilterOnline {
  isNil: Boolean
  eq: Boolean
  notEq: Boolean
  in: [Boolean!]
  lessThan: Boolean
  greaterThan: Boolean
  lessThanOrEqual: Boolean
  greaterThanOrEqual: Boolean
}

input DeviceFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceFilterDeviceId {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input DeviceFilterInput {
  and: [DeviceFilterInput!]

  or: [DeviceFilterInput!]

  not: [DeviceFilterInput!]

  id: DeviceFilterId

  "The Astarte device ID of the device."
  deviceId: DeviceFilterDeviceId

  "The display name of the device."
  name: DeviceFilterName

  "Whether the device is connected or not to Astarte"
  online: DeviceFilterOnline

  "The date at which the device last connected to Astarte."
  lastConnection: DeviceFilterLastConnection

  "The date at which the device last disconnected from Astarte."
  lastDisconnection: DeviceFilterLastDisconnection

  "The serial number of the device."
  serialNumber: DeviceFilterSerialNumber

  "The system model of the device"
  systemModel: SystemModelFilterInput

  "The tags of the device"
  tags: TagFilterInput

  "The groups the device belongs to."
  deviceGroups: DeviceGroupFilterInput

  "The existing OTA operations for this device"
  otaOperations: OtaOperationFilterInput

  applicationDeployments: DeploymentFilterInput
}

input DeviceSortInput {
  order: SortOrder
  field: DeviceSortField!
}

"""
Denotes a device instance that connects and exchanges data.

Each Device is associated to a specific SystemModel, which in turn is
associated to a specific HardwareType.
A Device also exposes info about its connection status and some sets of data read by its operating system.
"""
type Device implements Node {
  id: ID!

  "The Astarte device ID of the device."
  deviceId: String!

  "The display name of the device."
  name: String!

  "Whether the device is connected or not to Astarte"
  online: Boolean!

  "The date at which the device last connected to Astarte."
  lastConnection: DateTime

  "The date at which the device last disconnected from Astarte."
  lastDisconnection: DateTime

  "The serial number of the device."
  serialNumber: String

  "The system model of the device"
  systemModel: SystemModel

  "The tags of the device"
  tags(
    "How to sort the records in the response"
    sort: [TagSortInput]

    "A filter to limit the results"
    filter: TagFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [Tag!]!

  "The groups the device belongs to."
  deviceGroups(
    "How to sort the records in the response"
    sort: [DeviceGroupSortInput]

    "A filter to limit the results"
    filter: DeviceGroupFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [DeviceGroup!]!

  "The existing OTA operations for this device"
  otaOperations(
    "How to sort the records in the response"
    sort: [OtaOperationSortInput]

    "A filter to limit the results"
    filter: OtaOperationFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [OtaOperation!]!

  applicationDeployments(
    "How to sort the records in the response"
    sort: [DeploymentSortInput]

    "A filter to limit the results"
    filter: DeploymentFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): DeploymentConnection!

  availableImages: [ImageStatus!]

  availableVolumes: [VolumeStatus!]

  availableNetworks: [NetworkStatus!]

  "The capabilities that the device can support."
  capabilities: [DeviceCapability!]!

  cellularConnection: [Modem!]

  availableDeployments: [DeploymentStatus!]

  baseImage: BaseImageInfo

  availableContainers: [ContainerStatus!]

  batteryStatus: [BatterySlot!]

  hardwareInfo: HardwareInfo

  """
  Describes the place where the device is located.

  The field holds information about the device's address, which is
  estimated by means of Edgehog's geolocation modules and the data
  published by the device.
  """
  location: Location

  networkInterfaces: [NetworkInterface!]

  osInfo: OsInfo

  """
  Describes the position of a device.

  The field holds information about the GPS coordinates of the device,
  which are estimated by means of Edgehog's geolocation modules and the
  data published by the device.
  """
  position: Position

  runtimeInfo: RuntimeInfo

  storageUsage: [StorageUnit!]

  systemStatus: SystemStatus

  wifiScanResults: [WifiScanResult!]
}

input RequestForwarderSessionInput {
  deviceId: ID!
}

"The details of a forwarder session."
type ForwarderSession {
  "The token that identifies the session."
  id: ID!

  "The token that identifies the session."
  token: String!

  "The status of the session."
  status: ForwarderSessionStatus!

  "The hostname of the forwarder instance."
  forwarderHostname: String!

  "The port of the forwarder instance."
  forwarderPort: Int!

  "Indicates if TLS is used when the device connects to the forwarder."
  secure: Boolean!
}

"The details of a forwarder instance."
type ForwarderConfig {
  "A unique identifier"
  id: ID!

  "The hostname of the forwarder instance."
  hostname: String!

  "The port of the forwarder instance."
  port: Int!

  "Indicates if TLS should used when connecting to the forwarder."
  secureSessions: Boolean!
}

"The result of the :delete_device_group mutation"
type DeleteDeviceGroupResult {
  "The record that was successfully deleted"
  result: DeviceGroup

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_device_group mutation"
type UpdateDeviceGroupResult {
  "The successful result of the mutation"
  result: DeviceGroup

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateDeviceGroupInput {
  "The display name of the device group."
  name: String

  """
  The identifier of the device group.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  """
  The Selector that will determine which devices belong to the device group.

  This must be a valid selector expression, consult the Selector section of the Edgehog documentation for more information about Selectors.
  """
  selector: String
}

"The result of the :create_device_group mutation"
type CreateDeviceGroupResult {
  "The successful result of the mutation"
  result: DeviceGroup

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateDeviceGroupInput {
  "The display name of the device group."
  name: String!

  """
  The identifier of the device group.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  """
  The Selector that will determine which devices belong to the device group.

  This must be a valid selector expression, consult the Selector section of the Edgehog documentation for more information about Selectors.
  """
  selector: String!
}

enum DeviceGroupSortField {
  ID
  NAME
  HANDLE
  SELECTOR
}

input DeviceGroupFilterSelector {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceGroupFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceGroupFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input DeviceGroupFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input DeviceGroupFilterInput {
  and: [DeviceGroupFilterInput!]

  or: [DeviceGroupFilterInput!]

  not: [DeviceGroupFilterInput!]

  id: DeviceGroupFilterId

  "The display name of the device group."
  name: DeviceGroupFilterName

  """
  The identifier of the device group.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: DeviceGroupFilterHandle

  """
  The Selector that will determine which devices belong to the device group.

  This must be a valid selector expression, consult the Selector section of the Edgehog documentation for more information about Selectors.
  """
  selector: DeviceGroupFilterSelector

  "The devices belonging to the group."
  devices: DeviceFilterInput

  "The update channel associated with the group, if present."
  updateChannel: UpdateChannelFilterInput
}

input DeviceGroupSortInput {
  order: SortOrder
  field: DeviceGroupSortField!
}

type DeviceGroup implements Node {
  id: ID!

  "The display name of the device group."
  name: String!

  """
  The identifier of the device group.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  """
  The Selector that will determine which devices belong to the device group.

  This must be a valid selector expression, consult the Selector section of the Edgehog documentation for more information about Selectors.
  """
  selector: String!

  "The devices belonging to the group."
  devices(
    "How to sort the records in the response"
    sort: [DeviceSortInput]

    "A filter to limit the results"
    filter: DeviceFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [Device!]!

  "The update channel associated with the group, if present."
  updateChannel: UpdateChannel
}

enum TagSortField {
  ID
  NAME
}

input TagFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input TagFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input TagFilterInput {
  and: [TagFilterInput!]
  or: [TagFilterInput!]
  not: [TagFilterInput!]
  id: TagFilterId
  name: TagFilterName
}

input TagSortInput {
  order: SortOrder
  field: TagSortField!
}

"A Tag that can be applied to a resource."
type Tag {
  id: ID!
  name: String!
}

"The result of the :create_manual_ota_operation mutation"
type CreateManualOtaOperationResult {
  "The successful result of the mutation"
  result: OtaOperation

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateManualOtaOperationInput {
  "The ID identifying the Device the OTA Operation will be sent to"
  deviceId: ID!

  "The base image file, which will be uploaded to the storage."
  baseImageFile: Upload!
}

enum OtaOperationSortField {
  ID
  BASE_IMAGE_URL
  STATUS
  STATUS_PROGRESS
  STATUS_CODE
  MESSAGE
  CREATED_AT
  UPDATED_AT
}

input OtaOperationFilterUpdatedAt {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime!]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input OtaOperationFilterCreatedAt {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime!]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input OtaOperationFilterMessage {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input OtaOperationFilterStatusCode {
  isNil: Boolean
  eq: OtaOperationStatusCode
  notEq: OtaOperationStatusCode
  in: [OtaOperationStatusCode]
  lessThan: OtaOperationStatusCode
  greaterThan: OtaOperationStatusCode
  lessThanOrEqual: OtaOperationStatusCode
  greaterThanOrEqual: OtaOperationStatusCode
}

input OtaOperationFilterStatusProgress {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input OtaOperationFilterStatus {
  isNil: Boolean
  eq: OtaOperationStatus
  notEq: OtaOperationStatus
  in: [OtaOperationStatus!]
  lessThan: OtaOperationStatus
  greaterThan: OtaOperationStatus
  lessThanOrEqual: OtaOperationStatus
  greaterThanOrEqual: OtaOperationStatus
}

input OtaOperationFilterBaseImageUrl {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input OtaOperationFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input OtaOperationFilterInput {
  and: [OtaOperationFilterInput!]

  or: [OtaOperationFilterInput!]

  not: [OtaOperationFilterInput!]

  id: OtaOperationFilterId

  "The URL of the base image being installed on the device"
  baseImageUrl: OtaOperationFilterBaseImageUrl

  "The current status of the operation"
  status: OtaOperationFilterStatus

  "The percentage progress [0-100] for the current status"
  statusProgress: OtaOperationFilterStatusProgress

  "The current status code of the operation"
  statusCode: OtaOperationFilterStatusCode

  "A message with additional details about the current status"
  message: OtaOperationFilterMessage

  "The creation timestamp of the operation"
  createdAt: OtaOperationFilterCreatedAt

  "The timestamp of the last update to the operation"
  updatedAt: OtaOperationFilterUpdatedAt

  "The device targeted from the operation"
  device: DeviceFilterInput
}

input OtaOperationSortInput {
  order: SortOrder
  field: OtaOperationSortField!
}

"An OTA update operation"
type OtaOperation {
  id: ID!

  "The URL of the base image being installed on the device"
  baseImageUrl: String!

  "The current status of the operation"
  status: OtaOperationStatus!

  "The percentage progress [0-100] for the current status"
  statusProgress: Int!

  "The current status code of the operation"
  statusCode: OtaOperationStatusCode

  "A message with additional details about the current status"
  message: String

  "The creation timestamp of the operation"
  createdAt: DateTime!

  "The timestamp of the last update to the operation"
  updatedAt: DateTime!

  "The device targeted from the operation"
  device: Device!
}

type TenantInfo {
  id: ID!

  "The tenant name."
  name: String!

  "The tenant slug."
  slug: String!

  "The default locale supported by the tenant."
  defaultLocale: String!
}

enum UpdateTargetSortField {
  ID
  STATUS
  RETRY_COUNT
  LATEST_ATTEMPT
  COMPLETION_TIMESTAMP
}

input UpdateTargetFilterCompletionTimestamp {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input UpdateTargetFilterLatestAttempt {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input UpdateTargetFilterRetryCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateTargetFilterStatus {
  isNil: Boolean
  eq: UpdateTargetStatus
  notEq: UpdateTargetStatus
  in: [UpdateTargetStatus!]
  lessThan: UpdateTargetStatus
  greaterThan: UpdateTargetStatus
  lessThanOrEqual: UpdateTargetStatus
  greaterThanOrEqual: UpdateTargetStatus
}

input UpdateTargetFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateTargetFilterInput {
  and: [UpdateTargetFilterInput!]

  or: [UpdateTargetFilterInput!]

  not: [UpdateTargetFilterInput!]

  id: UpdateTargetFilterId

  "The status of the update target."
  status: UpdateTargetFilterStatus

  "The retry count of the update target. This indicates how many times Edgehog has tried to send an OTA update towards the device without receiving an ack."
  retryCount: UpdateTargetFilterRetryCount

  "The timestamp of the latest attempt to update the update target."
  latestAttempt: UpdateTargetFilterLatestAttempt

  "The timestamp when the update target completed its update, either with a success or a failure."
  completionTimestamp: UpdateTargetFilterCompletionTimestamp

  "The update campaign that is targeting the update target."
  updateCampaign: UpdateCampaignFilterInput

  "The target device."
  device: DeviceFilterInput

  "The OTA operation that tracks the update target in-progress update."
  otaOperation: OtaOperationFilterInput
}

input UpdateTargetSortInput {
  order: SortOrder
  field: UpdateTargetSortField!
}

"""
Represents an UpdateTarget.

An Update Target is the target of an Update Campaign, which is composed by the targeted device and the status of the target in the linked Update Campaign.
"""
type UpdateTarget {
  id: ID!

  "The status of the update target."
  status: UpdateTargetStatus!

  "The retry count of the update target. This indicates how many times Edgehog has tried to send an OTA update towards the device without receiving an ack."
  retryCount: Int!

  "The timestamp of the latest attempt to update the update target."
  latestAttempt: DateTime

  "The timestamp when the update target completed its update, either with a success or a failure."
  completionTimestamp: DateTime

  "The update campaign that is targeting the update target."
  updateCampaign: UpdateCampaign!

  "The target device."
  device: Device!

  "The OTA operation that tracks the update target in-progress update."
  otaOperation: OtaOperation
}

"The result of the :delete_update_channel mutation"
type DeleteUpdateChannelResult {
  "The record that was successfully deleted"
  result: UpdateChannel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

"The result of the :update_update_channel mutation"
type UpdateUpdateChannelResult {
  "The successful result of the mutation"
  result: UpdateChannel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateUpdateChannelInput {
  """
  The identifier of the update channel.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String

  "The display name of the update channel."
  name: String

  "The IDs of the target groups that are targeted by this update channel."
  targetGroupIds: [ID!]
}

"The result of the :create_update_channel mutation"
type CreateUpdateChannelResult {
  "The successful result of the mutation"
  result: UpdateChannel

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateUpdateChannelInput {
  """
  The identifier of the update channel.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the update channel."
  name: String!

  "The IDs of the target groups that are targeted by this update channel."
  targetGroupIds: [ID!]!
}

enum UpdateChannelSortField {
  ID
  HANDLE
  NAME
}

input UpdateChannelFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input UpdateChannelFilterHandle {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input UpdateChannelFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateChannelFilterInput {
  and: [UpdateChannelFilterInput!]

  or: [UpdateChannelFilterInput!]

  not: [UpdateChannelFilterInput!]

  id: UpdateChannelFilterId

  """
  The identifier of the update channel.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: UpdateChannelFilterHandle

  "The display name of the update channel."
  name: UpdateChannelFilterName

  "The device groups targeted by the update channel."
  targetGroups: DeviceGroupFilterInput
}

input UpdateChannelSortInput {
  order: SortOrder
  field: UpdateChannelSortField!
}

"""
Represents an UpdateChannel.

An UpdateChannel represents a set of device groups that can be targeted in an UpdateCampaign.
"""
type UpdateChannel implements Node {
  id: ID!

  """
  The identifier of the update channel.

  It should start with a lower case ASCII letter and only contain lower case ASCII letters, digits and the hyphen - symbol.
  """
  handle: String!

  "The display name of the update channel."
  name: String!

  "The device groups targeted by the update channel."
  targetGroups(
    "How to sort the records in the response"
    sort: [DeviceGroupSortInput]

    "A filter to limit the results"
    filter: DeviceGroupFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [DeviceGroup!]!
}

"The result of the :create_update_campaign mutation"
type CreateUpdateCampaignResult {
  "The successful result of the mutation"
  result: UpdateCampaign

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateUpdateCampaignInput {
  "The name of the update campaign."
  name: String!

  "The rollout mechanism used in the update campaign."
  rolloutMechanism: RolloutMechanismInput!

  "The ID of the base image that will be distributed in the update campaign."
  baseImageId: ID!

  "The ID of the update channel that will be targeted by the update campaign."
  updateChannelId: ID!
}

enum UpdateCampaignSortField {
  ID
  NAME
  STATUS
  OUTCOME
  TOTAL_TARGET_COUNT
  IDLE_TARGET_COUNT
  IN_PROGRESS_TARGET_COUNT
  FAILED_TARGET_COUNT
  SUCCESSFUL_TARGET_COUNT
}

input UpdateCampaignFilterSuccessfulTargetCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterFailedTargetCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterInProgressTargetCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterIdleTargetCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterTotalTargetCount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterOutcome {
  isNil: Boolean
  eq: UpdateCampaignOutcome
  notEq: UpdateCampaignOutcome
  in: [UpdateCampaignOutcome]
  lessThan: UpdateCampaignOutcome
  greaterThan: UpdateCampaignOutcome
  lessThanOrEqual: UpdateCampaignOutcome
  greaterThanOrEqual: UpdateCampaignOutcome
}

input UpdateCampaignFilterStatus {
  isNil: Boolean
  eq: UpdateCampaignStatus
  notEq: UpdateCampaignStatus
  in: [UpdateCampaignStatus!]
  lessThan: UpdateCampaignStatus
  greaterThan: UpdateCampaignStatus
  lessThanOrEqual: UpdateCampaignStatus
  greaterThanOrEqual: UpdateCampaignStatus
}

input UpdateCampaignFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input UpdateCampaignFilterId {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int!]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input UpdateCampaignFilterInput {
  and: [UpdateCampaignFilterInput!]

  or: [UpdateCampaignFilterInput!]

  not: [UpdateCampaignFilterInput!]

  id: UpdateCampaignFilterId

  "The name of the update campaign."
  name: UpdateCampaignFilterName

  "The status of the update campaign."
  status: UpdateCampaignFilterStatus

  "The outcome of the update campaign, present only when it's finished."
  outcome: UpdateCampaignFilterOutcome

  "The base image distributed by the update campaign."
  baseImage: BaseImageFilterInput

  "The update channel targeted by the update campaign."
  updateChannel: UpdateChannelFilterInput

  "The update targets belonging to the update campaign."
  updateTargets: UpdateTargetFilterInput

  "The total number of update targets."
  totalTargetCount: UpdateCampaignFilterTotalTargetCount

  "The number of update targets with an idle status."
  idleTargetCount: UpdateCampaignFilterIdleTargetCount

  "The number of update targets with an in-progress status."
  inProgressTargetCount: UpdateCampaignFilterInProgressTargetCount

  "The number of update targets with a failed status."
  failedTargetCount: UpdateCampaignFilterFailedTargetCount

  "The number of update targets with a successful status."
  successfulTargetCount: UpdateCampaignFilterSuccessfulTargetCount
}

input UpdateCampaignSortInput {
  order: SortOrder
  field: UpdateCampaignSortField!
}

"""
Represents an UpdateCampaign.

An Update Campaign is the operation that tracks the distribution of a specific Base Image to all devices belonging to an Update Channel.
"""
type UpdateCampaign implements Node {
  id: ID!

  "The name of the update campaign."
  name: String!

  "The status of the update campaign."
  status: UpdateCampaignStatus!

  "The outcome of the update campaign, present only when it's finished."
  outcome: UpdateCampaignOutcome

  "The rollout mechanism used in the update campaign."
  rolloutMechanism: RolloutMechanism!

  "The base image distributed by the update campaign."
  baseImage: BaseImage!

  "The update channel targeted by the update campaign."
  updateChannel: UpdateChannel!

  "The update targets belonging to the update campaign."
  updateTargets(
    "How to sort the records in the response"
    sort: [UpdateTargetSortInput]

    "A filter to limit the results"
    filter: UpdateTargetFilterInput

    "The number of records to return."
    limit: Int

    "The number of records to skip."
    offset: Int
  ): [UpdateTarget!]!

  "The total number of update targets."
  totalTargetCount: Int!

  "The number of update targets with an idle status."
  idleTargetCount: Int!

  "The number of update targets with an in-progress status."
  inProgressTargetCount: Int!

  "The number of update targets with a failed status."
  failedTargetCount: Int!

  "The number of update targets with a successful status."
  successfulTargetCount: Int!
}

type RootQueryType {
  "Returns a single update campaign."
  updateCampaign("The id of the record" id: ID!): UpdateCampaign

  "Returns a list of update campaigns."
  updateCampaigns(
    "How to sort the records in the response"
    sort: [UpdateCampaignSortInput]

    "A filter to limit the results"
    filter: UpdateCampaignFilterInput
  ): [UpdateCampaign!]!

  "Returns a single update channel."
  updateChannel("The id of the record" id: ID!): UpdateChannel

  "Returns a list of update channels."
  updateChannels(
    "How to sort the records in the response"
    sort: [UpdateChannelSortInput]

    "A filter to limit the results"
    filter: UpdateChannelFilterInput
  ): [UpdateChannel!]!

  "Retrieves the current tenant."
  tenantInfo: TenantInfo!

  "Returns Tags currently assigned to some device."
  existingDeviceTags(
    "How to sort the records in the response"
    sort: [TagSortInput]

    "A filter to limit the results"
    filter: TagFilterInput
  ): [Tag!]!

  "Returns a single device group."
  deviceGroup("The id of the record" id: ID!): DeviceGroup

  "Returns a list of device groups."
  deviceGroups(
    "How to sort the records in the response"
    sort: [DeviceGroupSortInput]

    "A filter to limit the results"
    filter: DeviceGroupFilterInput
  ): [DeviceGroup!]!

  """
  Fetches the forwarder config, if available.
  Without a configuration, forwarding functionalities are not available.
  """
  forwarderConfig: ForwarderConfig

  "Fetches a forwarder session by its token and the device ID."
  forwarderSession(token: String!, deviceId: ID!): ForwarderSession

  "Returns a single device."
  device("The id of the record" id: ID!): Device

  "Returns a list of devices."
  devices(
    "How to sort the records in the response"
    sort: [DeviceSortInput]

    "A filter to limit the results"
    filter: DeviceFilterInput
  ): [Device!]!

  "Returns a single hardware type."
  hardwareType("The id of the record" id: ID!): HardwareType

  "Returns a list of hardware types."
  hardwareTypes(
    "How to sort the records in the response"
    sort: [HardwareTypeSortInput]

    "A filter to limit the results"
    filter: HardwareTypeFilterInput
  ): [HardwareType!]!

  "Returns a single system model."
  systemModel("The id of the record" id: ID!): SystemModel

  "Returns a list of system models."
  systemModels(
    "How to sort the records in the response"
    sort: [SystemModelSortInput]

    "A filter to limit the results"
    filter: SystemModelFilterInput
  ): [SystemModel!]!

  "Returns all the available applications."
  applications(
    "How to sort the records in the response"
    sort: [ApplicationSortInput]

    "A filter to limit the results"
    filter: ApplicationFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): KeysetPageOfApplication

  "Returns the desired application."
  application("The id of the record" id: ID!): Application

  "Returns the desired image credentials."
  imageCredentials("The id of the record" id: ID!): ImageCredentials

  "Returns all available image credentials."
  listImageCredentials(
    "How to sort the records in the response"
    sort: [ImageCredentialsSortInput]

    "A filter to limit the results"
    filter: ImageCredentialsFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): KeysetPageOfImageCredentials

  "Returns the desired release."
  release("The id of the record" id: ID!): Release

  "Retrieves a Node from its global id"
  node("The Node unique identifier" id: ID!): Node!

  "Returns a single base image."
  baseImage("The id of the record" id: ID!): BaseImage

  "Returns a single base image collection."
  baseImageCollection("The id of the record" id: ID!): BaseImageCollection

  "Returns a list of base image collections."
  baseImageCollections(
    "How to sort the records in the response"
    sort: [BaseImageCollectionSortInput]

    "A filter to limit the results"
    filter: BaseImageCollectionFilterInput
  ): [BaseImageCollection!]!
}

type RootMutationType {
  "Creates a new update campaign."
  createUpdateCampaign(
    input: CreateUpdateCampaignInput!
  ): CreateUpdateCampaignResult

  "Creates a new update channel."
  createUpdateChannel(
    input: CreateUpdateChannelInput!
  ): CreateUpdateChannelResult

  "Updates an update channel."
  updateUpdateChannel(
    id: ID!
    input: UpdateUpdateChannelInput
  ): UpdateUpdateChannelResult

  "Deletes an update channel."
  deleteUpdateChannel(id: ID!): DeleteUpdateChannelResult

  "Initiates an OTA update with a user provided OS image"
  createManualOtaOperation(
    input: CreateManualOtaOperationInput!
  ): CreateManualOtaOperationResult

  "Creates a new device group."
  createDeviceGroup(input: CreateDeviceGroupInput!): CreateDeviceGroupResult

  "Updates a device group."
  updateDeviceGroup(
    id: ID!
    input: UpdateDeviceGroupInput
  ): UpdateDeviceGroupResult

  "Deletes a device group."
  deleteDeviceGroup(id: ID!): DeleteDeviceGroupResult

  """
  Requests a forwarder session for the specified device.
  Returns the session token.
  """
  requestForwarderSession(input: RequestForwarderSessionInput): String!

  "Updates a device."
  updateDevice(id: ID!, input: UpdateDeviceInput): UpdateDeviceResult

  "Add tags to a device."
  addDeviceTags(id: ID!, input: AddDeviceTagsInput!): AddDeviceTagsResult

  "Remove tags from a device."
  removeDeviceTags(
    id: ID!
    input: RemoveDeviceTagsInput!
  ): RemoveDeviceTagsResult

  "Sets led behavior."
  setDeviceLedBehavior(
    id: ID!
    input: SetDeviceLedBehaviorInput!
  ): SetDeviceLedBehaviorResult

  "Creates a hardware type."
  createHardwareType(input: CreateHardwareTypeInput!): CreateHardwareTypeResult

  "Updates a hardware type."
  updateHardwareType(
    id: ID!
    input: UpdateHardwareTypeInput
  ): UpdateHardwareTypeResult

  "Deletes a hardware type."
  deleteHardwareType(id: ID!): DeleteHardwareTypeResult

  "Creates a system model."
  createSystemModel(input: CreateSystemModelInput!): CreateSystemModelResult

  "Updates an system model."
  updateSystemModel(
    id: ID!
    input: UpdateSystemModelInput
  ): UpdateSystemModelResult

  "Deletes a system model."
  deleteSystemModel(id: ID!): DeleteSystemModelResult

  "Deploy the application on a device"
  deployRelease(input: DeployReleaseInput): DeployReleaseResult

  "Sends a :start command to the release on the device."
  startDeployment(id: ID!): StartDeploymentResult

  "Sends a :stop command to the release on the device."
  stopDeployment(id: ID!): StopDeploymentResult

  "Create image credentials."
  createImageCredentials(
    input: CreateImageCredentialsInput!
  ): CreateImageCredentialsResult

  deleteImageCredentials(id: ID!): DeleteImageCredentialsResult

  "Create a new base image in a base image collection."
  createBaseImage(input: CreateBaseImageInput!): CreateBaseImageResult

  "Updates a base image."
  updateBaseImage(id: ID!, input: UpdateBaseImageInput): UpdateBaseImageResult

  "Deletes a base image."
  deleteBaseImage(id: ID!): DeleteBaseImageResult

  "Creates a new base image collection."
  createBaseImageCollection(
    input: CreateBaseImageCollectionInput!
  ): CreateBaseImageCollectionResult

  "Updates a base image collection."
  updateBaseImageCollection(
    id: ID!
    input: UpdateBaseImageCollectionInput
  ): UpdateBaseImageCollectionResult

  "Deletes a base image collection."
  deleteBaseImageCollection(id: ID!): DeleteBaseImageCollectionResult
}

"""
The `Json` scalar type represents arbitrary json string data, represented as UTF-8
character sequences. The Json type is most often used to represent a free-form
human-readable json string.
"""
scalar JsonString

"""
The `Json` scalar type represents arbitrary json string data, represented as UTF-8
character sequences. The Json type is most often used to represent a free-form
human-readable json string.
"""
scalar Json

"""
The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime

"Represents an uploaded file."
scalar Upload

"""
Describes hardware-related info of a device.

It exposes data read by a device's operating system about the underlying hardware.
"""
type HardwareInfo {
  "The architecture of the CPU."
  cpuArchitecture: String

  "The reference code of the CPU model."
  cpuModel: String

  "The display name of the CPU model."
  cpuModelName: String

  "The vendor's name."
  cpuVendor: String

  "The Bytes count of memory."
  memoryTotalBytes: Int
}

"Describes the current usage of a storage unit on a device."
type StorageUnit {
  "The label of the storage unit."
  label: String!

  "The total number of bytes of the storage unit."
  totalBytes: Int

  "The number of free bytes of the storage unit."
  freeBytes: Int
}

"Describes the information on the system's base image for a device."
type BaseImageInfo {
  "The name of the image."
  name: String

  "The version of the image."
  version: String

  "Human readable build identifier of the image."
  buildId: String

  "A unique string that identifies the release, usually the image hash."
  fingerprint: String
}

"Describes an operating system of a device."
type OsInfo {
  "The name of the operating system."
  name: String

  "The version of the operating system."
  version: String
}

"Describes the current status of the operating system of a device."
type SystemStatus {
  "The identifier of the performed boot sequence."
  bootId: String

  "The number of free bytes of memory."
  memoryFreeBytes: Int

  "The number of running tasks on the system."
  taskCount: Int

  "The number of milliseconds since the last system boot."
  uptimeMilliseconds: Int

  "The date at which the system status was read."
  timestamp: DateTime!
}

"Describes the list of WiFi Access Points found by the device."
type WifiScanResult {
  "The channel used by the Access Point."
  channel: Int

  "Indicates whether the device is connected to the Access Point."
  connected: Boolean

  "The ESSID advertised by the Access Point."
  essid: String

  "The MAC address advertised by the Access Point."
  macAddress: String

  "The power of the radio signal, measured in dBm."
  rssi: Int

  "The date at which the device found the Access Point."
  timestamp: DateTime!
}

"Describes the status of a container on a device."
type ContainerStatus {
  "The identifier of the container."
  id: String

  "The status of the container."
  status: String
}

"Describes an Edgehog runtime."
type RuntimeInfo {
  "The name of the Edgehog runtime."
  name: String

  "The version of the Edgehog runtime."
  version: String

  "The environment of the Edgehog runtime."
  environment: String

  "The URL that uniquely identifies the Edgehog runtime implementation."
  url: String
}

"Describe the available images on the device."
type ImageStatus {
  "The image id."
  id: String

  "Whether the image is pulled or not."
  pulled: Boolean
}

"Describes the status of a deployment on a device."
type DeploymentStatus {
  "The deployment id."
  id: String

  "The deployment status, can be :stopped or :started"
  status: String
}

"Describes the status of a volume on a device."
type VolumeStatus {
  "The volume id."
  id: String

  "The volume status, wheather it was created or not."
  created: Boolean
}

"Describe the available networks on the device."
type NetworkStatus {
  "The network id."
  id: String

  "Whether the network has been created."
  created: Boolean
}
